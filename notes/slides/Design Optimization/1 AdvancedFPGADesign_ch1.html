<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>AdvancedFPGADesign.pdf</title><meta name="author" content="phm"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h3 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 17.5pt; }
 .h1 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 27.5pt; }
 h2 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 21pt; }
 .p, p { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; margin:0pt; }
 .s1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s2 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 .s3 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s4 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s5 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s7 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s8 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s9 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 3pt; }
 .s10 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 4pt; }
 .s11 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s12 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9pt; }
 .s13 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s14 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9.5pt; }
 .s15 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 .s16 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6pt; }
 .s17 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 .s18 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8pt; }
 .s19 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6pt; vertical-align: 4pt; }
 .s20 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6pt; }
 .s21 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s22 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s23 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6pt; vertical-align: -2pt; }
 .s24 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7pt; }
 .s25 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6pt; vertical-align: 1pt; }
 .s26 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 5pt; }
 .s27 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 6pt; }
 .s28 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 4pt; }
 .s29 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; vertical-align: 1pt; }
 .s30 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s31 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 3pt; }
 .s32 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 1pt; }
 .s33 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: 6pt; }
 .s34 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 4.5pt; vertical-align: 3pt; }
 .s35 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 4.5pt; }
 .s36 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s37 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s38 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s39 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 3pt; }
 .s40 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 .s41 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8.5pt; }
 .s42 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; vertical-align: 5pt; }
 .s43 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12.5pt; }
 .s44 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; vertical-align: 4pt; }
 .s45 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -1pt; }
 .s46 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 5pt; }
 .s47 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8.5pt; }
 .s48 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 4pt; }
 .s49 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 1pt; }
 .s50 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 1pt; }
 .s51 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 3.5pt; }
 .s52 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 4.5pt; }
 .s54 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: underline; font-size: 3.5pt; }
 .s55 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 3.5pt; }
 .s56 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 23pt; }
 .s57 { color: black; font-family:"Courier New", monospace; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s58 { color: black; font-family:"Courier New", monospace; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; vertical-align: -1pt; }
 .s59 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 2pt; }
 .s60 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 4pt; }
 .s61 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: 5pt; }
 .s62 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -4pt; }
 .s63 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -3pt; }
 .s64 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -2pt; }
 .s65 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s66 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; }
 .s67 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 2pt; }
 .s68 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s69 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: bold; text-decoration: none; font-size: 8.5pt; }
 .s70 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: -2pt; }
 .s72 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 1pt; }
 h4 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 16pt; }
 .s73 { color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7pt; vertical-align: 1pt; }
 .s74 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 25pt; vertical-align: -1pt; }
 .s75 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 25pt; vertical-align: 8pt; }
 .s76 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s77 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 2.5pt; }
 .s78 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; vertical-align: -2pt; }
 .s79 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; vertical-align: 5pt; }
 .s80 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: line-through; font-size: 7pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li:before {content: "• "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li:before {counter-increment: d1; content: counter(d1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l3 {padding-left: 0pt;counter-reset: d2 0; }
 #l3> li:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 10pt; }
 #l4 {padding-left: 0pt; }
 #l4> li:before {content: "• "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 li {display: block; }
 #l5 {padding-left: 0pt;counter-reset: e1 1; }
 #l5> li:before {counter-increment: e1; content: counter(e1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l6 {padding-left: 0pt;counter-reset: e2 1; }
 #l6> li:before {counter-increment: e2; content: counter(e1, decimal)"."counter(e2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l7 {padding-left: 0pt;counter-reset: f1 1; }
 #l7> li:before {counter-increment: f1; content: counter(f1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l8 {padding-left: 0pt;counter-reset: f2 3; }
 #l8> li:before {counter-increment: f2; content: counter(f1, decimal)"."counter(f2, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l9 {padding-left: 0pt;counter-reset: f3 0; }
 #l9> li:before {counter-increment: f3; content: counter(f1, decimal)"."counter(f2, decimal)"."counter(f3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 #l10 {padding-left: 0pt;counter-reset: g1 1; }
 #l10> li:before {counter-increment: g1; content: counter(g1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l11 {padding-left: 0pt;counter-reset: g2 2; }
 #l11> li:before {counter-increment: g2; content: counter(g1, decimal)"."counter(g2, decimal)" "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 #l12 {padding-left: 0pt;counter-reset: g3 3; }
 #l12> li:before {counter-increment: g3; content: counter(g1, decimal)"."counter(g2, decimal)"."counter(g3, decimal)" "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 9.5pt; }
 #l13 {padding-left: 0pt; }
 #l13> li:before {content: "• "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 li {display: block; }
 #l14 {padding-left: 0pt; }
 #l14> li:before {content: "• "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l15 {padding-left: 0pt; }
 #l15> li:before {content: "• "; color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
</style></head><body><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 4pt;text-align: left;"><span><img width="505" height="6" alt="image" src="1 AdvancedFPGADesign_ch1/Image_001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="16" height="60" alt="image" src="1 AdvancedFPGADesign_ch1/Image_002.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="13" height="322" alt="image" src="1 AdvancedFPGADesign_ch1/Image_003.png"/></span></p><h3 style="padding-top: 13pt;padding-left: 55pt;text-indent: -15pt;text-align: left;">Chapter <span class="h1">1</span></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 60pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="376" height="1" alt="image" src="1 AdvancedFPGADesign_ch1/Image_004.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-left: 55pt;text-indent: 0pt;text-align: left;">Architecting  Speed</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 39pt;text-indent: 0pt;line-height: 112%;text-align: justify;">Sophisticated tool optimizations are often not good enough to meet most design constraints if an arbitrary coding style is used. This chapter discusses the first of three primary physical characteristics of a digital design: speed. This chapter also discusses methods for architectural optimization in an FPGA.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 39pt;text-indent: 16pt;text-align: justify;">There are three primary definitions of speed depending on the context of the problem: throughput, latency, and timing. In the context of processing data in an FPGA, throughput refers to the amount of data that is processed per clock cyle. A common metric for throughput is bits per second. Latency refers to the tlme between data input and processed data output. The typical metric for latency will be time  or clock cycles. Timing refers to the logic delays between sequential elements. When we say a design does not &quot;meet timing,&quot; we mean that the delay of the critical path,  that is, the largest delay between flip-flops (composed of combinatorial delay, elk-to-out delay, routing delay, setup timing, clock  skew, and so on) is greater than the target clock period. The standard metrics for timing are clock period and frequency.</p><p style="padding-left: 55pt;text-indent: 0pt;line-height: 10pt;text-align: left;">During the course of this chapter, we will discuss the following topics in detail:</p><ul id="l1"><li style="padding-top: 5pt;padding-left: 62pt;text-indent: -6pt;line-height: 106%;text-align: left;"><p style="display: inline;">High-throughput  architectures  for  maximizing  the  number  of  bits  per second that can be processed by the design.</p></li><li style="padding-top: 2pt;padding-left: 61pt;text-indent: -6pt;line-height: 106%;text-align: left;"><p style="display: inline;">Low-latency  architectures  for minimizing  the  delay from the input  of  a module to the output.</p></li></ul><p class="s1" style="padding-top: 3pt;padding-left: 13pt;text-indent: 0pt;text-align: justify;">2    Chapter 1  Architecting Speed</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l2"><ol id="l3"><li style="padding-left: 40pt;text-indent: -25pt;text-align: justify;"><p class="s2" style="display: inline;">HIGH THROUGHPUT</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 11pt;text-indent: 1pt;text-align: justify;">A high-throughput design is one that is concerned with the steady-state data rate but less concerned about the time any specific piece of data requires to propagate through the design (latency). The idea with a high-throughput design is the same idea Ford came up with to manufacture automobiles in great quantities: an assem­</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">bly line. <span class="s3">In </span>the world of digital design where data is processed, we refer to this under a more abstract term: pipeline.</p><p style="padding-top: 2pt;padding-left: 9pt;text-indent: 17pt;text-align: justify;">A pipelined design conceptually works very similar to an assembly line in that the raw material or data input enters the front end, is passed through various stages of manipulation and processing, and then exits as a finished product or data output. The beauty of a pipelined design is that new data can begin processing before the prior data has finished, much like cars are processed on an assembly line. Pipelines are used in nearly all very-high-performance devices, and the variety of specific architectures is unlimited. Examples include CPU instruction sets, network protocol stacks, encryption engines, and so on.</p><p style="padding-top: 1pt;padding-left: 8pt;text-indent: 16pt;text-align: justify;">From an algorithmic perspective, an important concept in a pipelined design is that of &quot;unrolling the loop.&quot; As an example, consider the following piece of code that would most likely be used in a software implementation for finding the third power of <span class="s3">X. </span>Note that the term &quot;software&quot; here refers to code that is targeted at a set of procedural instructions that will be executed on a microprocessor.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">XPower = 1;</p><p class="s4" style="padding-top: 1pt;padding-left: 33pt;text-indent: -8pt;text-align: left;">for (i=O;i &lt; 3; i++) XPower = X <span class="s3">*  </span>XPower;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 1pt;text-align: justify;">Note that the above code is an iterative algorithm. The same variables and addresses are accessed until the computation is complete. There is no use for par­ allelism because a microprocessor only executes one instruction at a time (for the purpose of argument, just consider a single core processor). A similar implemen­ tation can be created in hardware. Consider the following Verilog implementation of the same algorithm (output scaling not considered):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 21pt;text-indent: 0pt;text-align: left;">module power3(</p><p class="s4" style="padding-top: 1pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">output [7:0] XPower,</p><ul id="l4"><li style="padding-top: 2pt;padding-left: 61pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">Timing optimizations to reduce the combinatorial delay of the critical path.</p></li></ul></li></ol></ol><p class="s4" style="padding-left: 55pt;text-indent: 0pt;line-height: 9pt;text-align: left;">output</p><p class="s4" style="padding-left: 55pt;text-indent: 0pt;line-height: 7pt;text-align: left;">input</p><p class="s4" style="padding-top: 1pt;padding-left: 33pt;text-indent: 0pt;text-align: left;">finished,</p><p class="s5" style="padding-left: 5pt;text-indent: 0pt;line-height: 6pt;text-align: left;">[7 :O J    X,</p><p style="padding-left: 72pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Adding register layers to divide combinatorial logic structures.</p><p style="padding-left: 83pt;text-indent: -10pt;text-align: left;">Parallel  structures for separating  sequentially  executed operations into parallel operations.</p><p style="padding-left: 72pt;text-indent: 0pt;text-align: left;">Flattening logic structures specific to priority encoded signals.</p><p style="padding-left: 83pt;text-indent: -10pt;line-height: 106%;text-align: left;">Register balancing to redistribute combinatorial logic around pipelined registers.</p><p style="padding-left: 72pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Reordering paths to divert operations in a critical path to a noncritical path.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 38pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="88" height="1" alt="image" src="1 AdvancedFPGADesign_ch1/Image_005.png"/></span></p><p class="s5" style="padding-left: 38pt;text-indent: 0pt;line-height: 8pt;text-align: left;"><i>Advanced FPGA Design. </i>By Steve Kilts Copyright <span class="s7">© </span>2007 John Wiley <span class="s8">&amp; </span>Sons, Inc.</p><p class="s9" style="padding-top: 2pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">input       <span class="s4"> elk, start); // the duration of start is a</span></p><p class="s4" style="padding-left: 182pt;text-indent: 0pt;line-height: 8pt;text-align: left;">single clock</p><p class="s4" style="padding-left: 39pt;text-indent: 0pt;line-height: 8pt;text-align: left;">reg    [7:0] ncount;</p><p class="s4" style="padding-top: 1pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">reg    [7:0] XPower;</p><p class="s4" style="padding-left: 38pt;text-indent: 0pt;line-height: 13pt;text-align: left;">assign finished = (ncount    0); always@(posedge elk)</p><p class="s4" style="padding-left: 57pt;text-indent: -8pt;line-height: 110%;text-align: left;">if(start) begin XPower &lt;= X; ncount &lt;= 2;</p><p class="s4" style="padding-left: 47pt;text-indent: 0pt;line-height: 8pt;text-align: left;">end</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="15" height="95" alt="image" src="1 AdvancedFPGADesign_ch1/Image_006.gif"/></span></p><p class="s10" style="text-indent: 0pt;text-align: right;">\</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 2pt;padding-left: 223pt;text-indent: 0pt;text-align: left;">1.1 <span class="s1">High Throughput     </span><span class="s12">3</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 51pt;text-indent: -9pt;line-height: 10pt;text-align: left;">else if(!finished) begin neount <span class="s13">&lt;= </span>neount - 1; XPower <span class="s13">&lt;= </span>XPower <span class="s14">*  </span>X;</p><p class="s4" style="padding-top: 1pt;padding-left: 22pt;text-indent: 19pt;line-height: 108%;text-align: left;">end endrnodule</p><p class="s3" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;line-height: 109%;text-align: justify;">In <span class="p">the above example, the same register and computational resources are reused until the computation is finished as shown in Figure 1.1.</span></p><p style="padding-left: 6pt;text-indent: 15pt;line-height: 9pt;text-align: left;">With this type of iterative implementation, no new computations can begin</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">until the previous computation has completed. This iterative scheme is  very similar to a software implementation. Also note that certain handshaking signals are required to indicate the beginning and completion of a computation. An external module must also use the handshaking to pass new data to the module and receive a completed calculation. The performance of this implementation is</p><p style="padding-top: 6pt;padding-left: 22pt;text-indent: 0pt;line-height: 110%;text-align: left;">Throughput <span class="s11">= </span>8/3, or 2.7 bits/clock Latency <span class="s15">= </span>3 clocks</p><p style="padding-left: 6pt;text-indent: 15pt;line-height: 11pt;text-align: left;">Timing  <span class="s15">= </span>One multiplier delay in the critical path</p><p style="padding-top: 5pt;padding-left: 23pt;text-indent: -16pt;text-align: left;">Contrast this with a pipelined version of the same algorithm:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">module power3(</p><p class="s4" style="padding-left: 33pt;text-indent: 0pt;line-height: 111%;text-align: left;">output reg [7:0] XPower, input            elk,</p><p class="s4" style="padding-left: 33pt;text-indent: 0pt;line-height: 9pt;text-align: left;">input      [7:0] X</p><p class="s16" style="padding-top: 2pt;padding-left: 34pt;text-indent: 0pt;text-align: left;">) ;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s17" style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">4    <span class="s1">Chapter 1   Architecting Speed</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="404" height="94" alt="image" src="1 AdvancedFPGADesign_ch1/Image_007.gif"/></span></p><p class="s18" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Figure 1.2    <span class="s5">Pipelined implementation.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">In the above implementation, the value of X is passed  to both pipeline  stages where independent resources compute the corresponding multiply operation: Note that while X is being used to calculate the final power of 3 in the second pipeline stage, the next value  of X can be sent to the first pipeline stage as shown in Figure 1.2.</p><p style="padding-left: 6pt;text-indent: 16pt;line-height: 10pt;text-align: left;">Both the final calculation of X<span class="s19">3</span><span class="s20"> </span>(XPower3 resources) and the first calculation</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">of the next value of X (XPower2 resources) occr simultaneously. The perform­ ance of this design is</p><p style="padding-top: 3pt;padding-left: 22pt;text-indent: 0pt;line-height: 121%;text-align: left;">Throughput <span class="s21">= </span>8/1, or 8 bits/clock Latency <span class="s11">= </span>3 clocks</p><p style="padding-left: 22pt;text-indent: 0pt;text-align: left;">Timing <span class="s11">= </span>One multiplier delay in the critical path</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">The throughput performance increased by a factor of 3 over the iterative implementation. In general, if an algorithm requiring n iterative loops is &quot;unrolled,&quot; the pipelined implementation will exhibit a throughput performance</p><p class="s4" style="padding-left: 33pt;text-indent: 0pt;line-height: 108%;text-align: right;">reg reg</p><p class="s4" style="padding-left: 33pt;text-indent: 0pt;line-height: 8pt;text-align: left;">[7:0] XPowerl, XPower2;</p><p class="s4" style="padding-top: 1pt;padding-left: 33pt;text-indent: 0pt;text-align: left;">[7:0] Xl, X2;</p><p style="padding-left: 33pt;text-indent: 0pt;line-height: 11pt;text-align: left;">increase of a factor of n. There was no penalty in terms of latency as the pipelined implementation  still required 3 clocks to propagate the final computation. Like­</p><p class="s4" style="padding-left: 44pt;text-indent: -10pt;line-height: 7pt;text-align: left;">always @(posedge elk) begin</p><p class="s4" style="padding-left: 43pt;text-indent: 0pt;line-height: 108%;text-align: left;"><span class="s22">I I </span>Pipeline stage 1 Xl     <span class="s13">&lt;= </span>X;</p><p class="s4" style="padding-left: 43pt;text-indent: 0pt;text-align: left;">XPowerl <span class="s13">&lt;= </span>X;</p><p class="s4" style="padding-top: 3pt;padding-left: 43pt;text-indent: 0pt;text-align: left;"><span class="s22">I I </span>Pipeline stage 2 X2     <span class="s13">&lt;= </span>Xl;</p><p class="s4" style="padding-left: 44pt;text-indent: -1pt;line-height: 9pt;text-align: left;">XPower2 <span class="s13">&lt;= </span>XPowerl <span class="s14">* </span>Xl;</p><p class="s4" style="padding-top: 3pt;padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span class="s22">I I </span>Pipeline stage 3 XPower <span class="s13">&lt;= </span>XPower2 <span class="s14">* </span>X2;</p><p style="text-indent: 0pt;text-align: left;"><span><img width="324" height="80" alt="image" src="1 AdvancedFPGADesign_ch1/Image_008.png"/></span></p><p class="s4" style="padding-top: 1pt;padding-left: 25pt;text-indent: 9pt;line-height: 108%;text-align: left;">end endrnodule</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s16" style="padding-left: 124pt;text-indent: 0pt;line-height: 63%;text-align: left;">D[7:0]   0[7:0] [<span class="s23">7</span>:0] E</p><p class="s24" style="padding-left: 122pt;text-indent: 0pt;line-height: 6pt;text-align: left;">                         <span class="s5">       .                                       </span>l<span class="s25">7</span><span class="s16">_:0-]&quot;i</span><span class="s5">XPower   :O</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s26" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">l?ianrl&#39;.l <span class="s27">1 1   </span><span class="s28">TtPr!it1vP </span>imn1PmPntM-icm</p><p style="padding-left: 9pt;text-indent: 0pt;text-align: justify;">wise, there was no timing penalty as the critical path still contained only one multiplier.</p><p class="s1" style="padding-top: 6pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">Unrolling an iterative loop increases throughput.</p><p style="padding-top: 5pt;padding-left: 9pt;text-indent: 16pt;text-align: justify;">The penalty to pay for unrolling loops such as this is an increase in area. The iterative implementation required a single register and multiplier (along with some control logic not shown in the diagram), whereas the pipelined implementation required a separate register for both X and XPower and a separate multiplier for every pipeline stage. Optimizations for area are discussed in the Chapter 2.</p><p class="s1" style="padding-top: 6pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">The penalty for unrolling an iterative loop is a proportional increase in area.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 6pt;padding-left: 10pt;text-indent: 0pt;text-align: justify;">1.2   LOW LATENCY</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 9pt;text-indent: 0pt;text-align: justify;">A low-latency design is one that passes the data from the input to the output as quickly as possible by minimizing the intermediate processing delays. Oftentimes, a low-latency design will require parallelisms, removal of pipelining, and logical short cuts that may reduce the throughput or the max clock speed in a design.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l5"><ol id="l6"><li style="padding-top: 6pt;padding-left: 251pt;text-indent: -11pt;text-align: right;"><p class="s1" style="display: inline;">Low Latency     <span class="s12">5</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="text-indent: 0pt;text-align: right;">Referring back to our power-of-3 example, there is no obvious laency opim-</p><p class="s29" style="text-indent: 0pt;line-height: 6pt;text-align: right;">.  <span class="s7"> 0</span>·    <span class="s7"> to be made to the iterative implementation  as each  successive multiply</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="0" height="60" alt="image" src="1 AdvancedFPGADesign_ch1/Image_009.png"/></span></p><p class="s30" style="padding-top: 4pt;padding-left: 13pt;text-indent: 0pt;line-height: 7pt;text-align: left;">I &#39; : /</p><p class="s31" style="padding-left: 15pt;text-indent: 0pt;line-height: 3pt;text-align: left;">1</p><p class="s32" style="padding-left: 13pt;text-indent: 0pt;text-align: left;">1               <span class="s31">1</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="text-indent: 0pt;line-height: 7pt;text-align: left;">:</p><p style="text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-left: 13pt;text-indent: 0pt;text-align: left;">!<span class="s8"> </span><span class="s34">I</span>&#39;,<span class="s8">i</span><span class="s34">,</span>&#39;I,:<span class="s34">,</span><span class="s35">                                                     </span><span class="s12">6    </span><span class="s1">Chapter 1   Architecting Speed</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 63pt;text-indent: 0pt;line-height: 11pt;text-align: left;">low-latency implementation,  the clock period must be at least two multiplier delays (depending on the implementation) plus any external logic in the critical path.</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 2pt;text-align: left;">iza  on                                                                                       ·</p><p style="padding-left: 7pt;text-indent: 0pt;line-height: 2pt;text-align: left;">.   <span class="s7">d  ·    </span>1</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">operation  must  be  registered  for  the  next  operation.  The pipe<span class="p">1</span>me    imp_emn-</p><p class="s7" style="padding-left: 7pt;text-indent: 0pt;line-height: 110%;text-align: justify;">tation, however, has a clear path to reducing latency. Note that at each p1pe1e stage, the product of each multiply must wait until the next clock edge befr <span class="s36">I </span>is propagated to the next stage. By removing the pipeline registers, we can nnmnnze the input to output timing:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 22pt;text-indent: 0pt;text-align: left;">module power3(</p><p class="s4" style="padding-left: 33pt;text-indent: 0pt;line-height: 109%;text-align: left;">output [7:0] XPower, input [7:OJ X</p><p class="s16" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">) ;</p><p class="s4" style="padding-top: 1pt;padding-left: 33pt;text-indent: 0pt;line-height: 109%;text-align: left;">reg   [7:0] XPowerl, XPower2; reg    [7:0] Xl, X2;</p><p class="s4" style="padding-top: 1pt;padding-left: 32pt;text-indent: 0pt;text-align: left;">assign XPower <span class="s21">=  </span>XPower2 * X2;</p><p class="s4" style="padding-top: 5pt;padding-left: 42pt;text-indent: -9pt;line-height: 111%;text-align: left;">always @* begin Xl       X;</p><p class="s4" style="padding-left: 33pt;text-indent: 9pt;line-height: 9pt;text-align: left;">XPowerl <span class="s21">= </span>X;</p><p class="s4" style="padding-left: 33pt;text-indent: 0pt;text-align: left;">end</p><p class="s4" style="padding-top: 5pt;padding-left: 42pt;text-indent: -9pt;line-height: 109%;text-align: left;">always @* begin X2       Xl;</p><p class="s4" style="padding-left: 32pt;text-indent: 9pt;line-height: 9pt;text-align: left;">XPower2 <span class="s21">= </span>XPowerl*Xl;</p><p class="s4" style="padding-left: 22pt;text-indent: 9pt;line-height: 109%;text-align: left;">end endmodule</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 6pt;text-indent: 0pt;line-height: 110%;text-align: justify;">In the above example, the registers were stripped out of the pipeline. Each stage is a combinatorial expression of the previous as shown in Figure 1.3.</p><p class="s7" style="padding-left: 22pt;text-indent: 0pt;text-align: left;">The performance of this design is</p><p class="s7" style="padding-top: 6pt;padding-left: 22pt;text-indent: 0pt;line-height: 110%;text-align: left;">Throughput <span class="s11">= </span>8 bits/clock (assuming one new input per clock) Latency <span class="s15">= </span>Between one and two multiplier delays, <span class="p">0 </span>clocks Timing <span class="s21">= </span>Two multiplier delays in the critical path</p><p class="s7" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;line-height: 110%;text-align: justify;">By removing the pipeline registers, we have reduced the latency of this design below a single clock cycle.</p><p class="s1" style="padding-top: 6pt;padding-left: 22pt;text-indent: 0pt;text-align: left;">Latency can be reduced by removing pipeline registers.</p><p class="s7" style="padding-top: 6pt;padding-left: 6pt;text-indent: 15pt;line-height: 107%;text-align: left;">The penalty  is clearly  <span class="s37">in </span>the  timing.  Previous  impleentation  c?uld  thoreti­ cally run the system clock period close to the delay of a smgle multiplier, but m the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 10pt;text-indent: 0pt;text-align: center;">[7:0]</p><p style="text-indent: 0pt;text-align: left;"><span><img width="217" height="44" alt="image" src="1 AdvancedFPGADesign_ch1/Image_010.png"/></span></p><p class="s38" style="padding-left: 202pt;text-indent: 0pt;line-height: 9pt;text-align: left;">1----   ;[.<span class="s39">7</span><span class="s5">_:0-]&#39;i XPower[7:0]</span></p><p class="s1" style="padding-top: 6pt;padding-left: 32pt;text-indent: 0pt;line-height: 8pt;text-align: left;">The penalty for removing pipeline registers is an increase in combinatorial delay between registers.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="padding-top: 5pt;padding-left: 16pt;text-indent: 0pt;text-align: justify;">1.3   TIMING</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 12pt;text-indent: 2pt;line-height: 110%;text-align: justify;">Timing refers to the clock speed of a design. The maximum delay between any two sequential elements in a design will determine the max clock speed. The idea of clock speed exists on a lower level of abstraction than the speed/area trade-offs discussed elsewhere in this chapter as clock speed in  general  is  not  directly related to these topologies, although trade-offs within these architectures will cer­ tainly have an impact on timing. For example, one cannot know whether a pipe­ lined topology will run faster than an iterative without knowing the details of the implementation.  The maximum  speed, or maximum  frequency,  can be defined</p><p class="s7" style="padding-top: 1pt;padding-left: 12pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">according to the straightforward and well-known maximum-frequency equation (ignoring clock-to-clock jitter):</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-left: 11pt;text-indent: 0pt;text-align: justify;">Equation 1.1 Maximum Frequency</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s3" style="text-indent: 0pt;line-height: 9pt;text-align: left;">-</p><p style="text-indent: 0pt;text-align: left;"/><p class="s3" style="padding-left: 74pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s7">Fmax </span>= --------<span class="s42">I</span> -------</p><p class="s7" style="padding-left: 10pt;text-indent: 92pt;line-height: 12pt;text-align: left;">Tc1k-q <span class="s43">+</span>T1ogic <span class="s43">+</span>Trouting <span class="s43">+ </span>Tsetup - Tskew             <span class="s44">(1.1)</span></p><p class="s7" style="padding-top: 5pt;padding-left: 9pt;text-indent: 1pt;line-height: 109%;text-align: justify;">where Fmax is maximum allowable frequency for clock; Tclk-q is time from clock <span class="s29">arrival</span> until data arrives at Q; T<span class="s20">1</span><span class="s29">ogic</span> is propagation delay through logic between flip-flops; Trouting is routing delay between flip-flops; Tsetup is minimum time data must arrive at D before the next rising edge of clock (setup time); and Tskew is propagation delay of clock between the launch flip-flop and the capture flip-flop.</p><p class="s7" style="padding-top: 1pt;padding-left: 8pt;text-indent: 16pt;line-height: 8pt;text-align: left;">The  next  sections  describes  various  methods  and  trade-offs  required  to improve timing performance.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l7"><ol id="l8"><ol id="l9"><li style="padding-left: 44pt;text-indent: -35pt;text-align: justify;"><p class="s40" style="display: inline;">Add Register Layers</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 6pt;text-indent: 1pt;line-height: 109%;text-align: justify;">The first strategy for architectural timing improvements is to add intermediate layers of registers to the critical path. This technique should be used in highly pipelined  designs  where an additional  clock cycle latency  does not violate the</p><p class="s7" style="padding-left: 6pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">design specifications, and the overall  functionality will not be affected  by the further addition of registers.</p><p class="s7" style="padding-top: 3pt;padding-left: 6pt;text-indent: 16pt;line-height: 9pt;text-align: left;">For instance, assume the architecture for the following FIR (Finite Impulse Response) implementation does not meet timing:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">X[7:0</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s5" style="padding-left: 12pt;text-indent: 0pt;text-align: left;">[7:0]</p><p class="s24" style="padding-left: 12pt;text-indent: 0pt;line-height: 6pt;text-align: center;">                     [7:0]   </p><p class="s4" style="padding-top: 2pt;padding-left: 13pt;text-indent: 0pt;text-align: center;">[7:0]</p><p class="s4" style="padding-left: 12pt;text-indent: 0pt;line-height: 9pt;text-align: left;">[7:0]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 23pt;text-indent: -10pt;line-height: 114%;text-align: left;">module fir( output <span class="s5">[7 :0]  Y,</span></p><p class="s18" style="padding-left: 5pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Figure 1.3    <span class="s5">Low-latency implementation.</span></p><p class="s4" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">input  [7:0] A, B, C, X,</p><p class="s4" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">input        <span class="s45">elk.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 660pt;text-indent: 0pt;line-height: 5pt;text-align: left;"><span><img width="136" height="7" alt="image" src="1 AdvancedFPGADesign_ch1/Image_011.gif"/></span></p><p class="s46" style="padding-top: 3pt;padding-left: 7pt;text-indent: 0pt;text-align: center;">I   <span class="s35">I</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="text-indent: 0pt;text-align: right;">1.3 Timing     <span class="s47">7</span></p><p class="s47" style="padding-top: 3pt;padding-left: 132pt;text-indent: 0pt;text-align: left;">8    <span class="s1">Chapter 1   Architecting Speed</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-top: 6pt;padding-left: 28pt;text-indent: 0pt;line-height: 106%;text-align: left;">input reg</p><p style="text-indent: 0pt;text-align: left;"><span><img width="360" height="119" alt="image" src="1 AdvancedFPGADesign_ch1/Image_012.gif"/></span></p><p class="s4" style="padding-top: 4pt;padding-left: 9pt;text-indent: 26pt;line-height: 110%;text-align: left;">validsample); [7:0] Xl, X2 , Y;</p><p class="s4" style="padding-top: 3pt;padding-left: 38pt;text-indent: -10pt;text-align: left;">always @(posedge elk) if(validsample) begin</p><p class="s4" style="padding-left: 48pt;text-indent: 0pt;text-align: left;">Xl <span class="s30">&lt;=  </span>X; X2 <span class="s30">&lt;=  </span>Xl;</p><p class="s8" style="padding-left: 48pt;text-indent: 0pt;line-height: 8pt;text-align: left;">y <span class="s30">&lt;= </span><span class="s4">A* X+B* Xl+C* X2;</span></p><p class="s4" style="padding-top: 2pt;padding-left: 20pt;text-indent: 19pt;line-height: 106%;text-align: left;">end endmodule</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-top: 6pt;padding-left: 20pt;text-indent: 0pt;text-align: left;">Figure <b>1.5    </b><span class="s5">Pipeline registers added.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s48" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">f7;0J</p><p class="s31" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">(7:0]</p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 15pt;line-height: 13pt;text-align: left;">Architecturally,  all  multiply/add  operations  occur  in  one  clock  cycle  as shown in Figure 1.4.                                                                                   .</p><p style="padding-left: 5pt;text-indent: 15pt;line-height: 7pt;text-align: left;">In other words, the critical path of one multiplier and one adder _is greatr</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">than the minimum clock period requirement. Assumig the latecy reqmremnt is not fixed at 1 clock, we can further pipeline this design by addmg etra _registers intermediate to the multipliers. The first layer is easy: just add a p1pelme layer</p><p style="padding-top: 2pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">between the multipliers and the adder:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 22pt;text-indent: 0pt;line-height: 9pt;text-align: left;">module fir(</p><p class="s4" style="padding-left: 32pt;text-indent: 0pt;line-height: 9pt;text-align: left;">output [7:0] Y,</p><p class="s4" style="padding-left: 33pt;text-indent: 0pt;line-height: 9pt;text-align: left;">input  [7:0] A, B, C, X,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">In the above example, the adder was separated from the multipliers with a pipe­ line stage as shown in Figure 1.5.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">Multipliers are good candidates for pipelining because the calculations can easily be broken up into stages. Additional pipelining is possible by breaking the multipliers and adders up into stages that can be individually registered.</p><p class="s1" style="padding-top: 6pt;padding-left: 21pt;text-indent: 0pt;text-align: left;">Adding register layers improves timing by dividing the critical path into two paths of smaller delay.</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 16pt;line-height: 11pt;text-align: justify;">Various implementations of these functions are covered in other chapters, but once the architecture has been broken up into stages, additional pipelining is as straightforward as the above example.</p><p class="s4" style="padding-left: 33pt;text-indent: 0pt;line-height: 7pt;text-align: left;">input</p><p class="s4" style="padding-left: 33pt;text-indent: 0pt;line-height: 106%;text-align: left;">input reg reg</p><p class="s4" style="padding-left: 36pt;text-indent: 0pt;line-height: 5pt;text-align: left;">elk,</p><p class="s4" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">validsample) ;</p><p class="s5" style="padding-left: 9pt;text-indent: 0pt;line-height: 9pt;text-align: left;">[ 7 : 0 ]  <span class="s4">Xl , X2 , </span>Y;</p><p class="s4" style="padding-left: 9pt;text-indent: 0pt;line-height: 9pt;text-align: left;">[7:0] prodl, prod2, prod3;</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li style="padding-left: 68pt;text-indent: -35pt;text-align: left;"><p class="s40" style="display: inline;">Parallel Structures</p><p class="s4" style="padding-top: 3pt;padding-left: 44pt;text-indent: -10pt;line-height: 110%;text-align: left;">always @ (posedge elk) begin if(validsample) begin</p><p class="s4" style="padding-left: 53pt;text-indent: 0pt;line-height: 9pt;text-align: left;">Xl   <span class="s30">&lt;=  </span>X;</p><p class="s4" style="padding-left: 53pt;text-indent: 0pt;line-height: 9pt;text-align: left;">X2   <span class="s30">&lt;=  </span><span class="s49">Xl;</span></p><p class="s4" style="padding-left: 54pt;text-indent: 0pt;line-height: 80%;text-align: left;">prodl <span class="s30">&lt;= </span><span class="s49">A</span> <span class="s37">* </span>X; prod2 <span class="s30">&lt;=  </span><span class="s50">B </span><span class="s5"> </span><span class="s37">* </span><span class="s5">Xl; </span>prod3 <span class="s30">&lt;= </span><span class="s49">C</span> <span class="s37">* </span>X2;</p><p class="s4" style="padding-top: 1pt;padding-left: 45pt;text-indent: 0pt;line-height: 9pt;text-align: left;">end</p><p class="s8" style="padding-left: 36pt;text-indent: 9pt;line-height: 129%;text-align: left;">y <span class="s30">&lt;= </span><span class="s4">prodl + prod2 + prod3; end</span></p><p class="s4" style="text-indent: 0pt;line-height: 7pt;text-align: center;">endmodule</p><p style="padding-top: 5pt;padding-left: 26pt;text-indent: 0pt;text-align: justify;">The second strategy for architectural timing improvements is to reorganize the critical path such that logic structures are implemented in parallel. This technique should be used whenever a function that currently evaluates through a serial string of logic can be broken up and evaluated in parallel. For instance, assume that the standard pipelined power-of-3 design discussed in previous sections does not meet timing. To create parallel structures, we can break the multipliers into independent operations and then recombine them. For instance, an 8-bit binary multiplier can be represented by nibbles A and B:</p><p class="s3" style="padding-top: 5pt;text-indent: 0pt;text-align: center;">X <span class="p">= {A, B},</span></p><p style="padding-top: 5pt;padding-left: 26pt;text-indent: 0pt;line-height: 8pt;text-align: justify;">where A is the most significant nibble and B is the least significant.</p><p class="s51" style="padding-left: 4pt;text-indent: 0pt;line-height: 4pt;text-align: center;">(7:0]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 17pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="190" height="1" alt="image" src="1 AdvancedFPGADesign_ch1/Image_013.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="352" height="152" alt="image" src="1 AdvancedFPGADesign_ch1/Image_014.png"/></span></p><p class="s52" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">[7&#39;0&#39;.]&#39;...                                                                                      <u>,</u>11&quot;,01-</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s48" style="padding-left: 149pt;text-indent: 0pt;text-align: left;">(7:0]                                                                                                                           <span class="s54">[7:0            </span></p><p style="padding-top: 2pt;padding-left: 17pt;text-indent: 15pt;text-align: left;">Because  the  multiplicand  is  equal  to  the  multiplier  in  our  power-of-3 example, the multiply operation can be reorganized as follows:</p><p style="padding-top: 5pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">X  * X = {A, B}  *  {A, B} = {(A * A), (2 * A  * B), (B  * B)};</p><p class="s51" style="padding-top: 1pt;padding-left: 21pt;text-indent: 0pt;text-align: left;">B  :O     7:0]</p><p class="s51" style="padding-top: 2pt;text-indent: 0pt;text-align: right;">[7:0]</p><p class="s55" style="text-indent: 0pt;text-align: right;">(7:0)</p><p style="padding-top: 4pt;padding-left: 21pt;text-indent: 0pt;text-align: left;">This reduces our problem to a series of 4-bit multiplications and then recombining the products. This can be implemented with the following module:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">module power3(</p><p class="s4" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">output [7:0] XPower,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span><img width="325" height="2" alt="image" src="1 AdvancedFPGADesign_ch1/Image_015.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="text-indent: 0pt;text-align: right;">1.3 <span class="s1">Timing    </span><span class="s12">9</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="25" height="181" alt="image" src="1 AdvancedFPGADesign_ch1/Image_016.gif"/></span></p><p class="s12" style="padding-left: 62pt;text-indent: 0pt;text-align: left;">10    <span class="s1">Chapter 1   Architecting Speed</span></p><p class="s56" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">-------</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-top: 4pt;padding-left: 62pt;text-indent: 0pt;text-align: left;">input  [7:0J X, input        elk);</p><p class="s4" style="padding-left: 63pt;text-indent: 0pt;line-height: 8pt;text-align: left;">reg    [7:0J XPowerl;</p><p class="s57" style="padding-left: 63pt;text-indent: 0pt;line-height: 10pt;text-align: left;">I I <span class="s4">partial product registers</span></p><p class="s4" style="padding-left: 63pt;text-indent: 0pt;line-height: 9pt;text-align: left;">reg   [3:0J XPower2_ppAA, XPower2_ppAB,</p><p class="s4" style="padding-left: 63pt;text-indent: 0pt;line-height: 124%;text-align: left;">reg    [3:0J XPower3_ppAA, XPower3_ppAB, reg    [7:OJ Xl , X2 ;</p><p class="s4" style="padding-left: 63pt;text-indent: 0pt;line-height: 8pt;text-align: left;">wire   [7:0J XPower2;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="401" height="165" alt="image" src="1 AdvancedFPGADesign_ch1/Image_017.gif"/></span></p><p class="s4" style="padding-left: 3pt;text-indent: 0pt;text-align: left;">XPower2_ppBB; XPower3_ppBB;</p><p class="s58" style="padding-top: 6pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">I<span class="s57"> I </span><span class="s4">nibbles</span></p><p class="s4" style="padding-left: 3pt;text-indent: 0pt;line-height: 13pt;text-align: left;">for partial <span class="s49">products</span> <span class="s59">(</span>A is <span class="s9">MS</span> <span class="s60">nibble,</span> <span class="s61">B</span> is <span class="s61">LS</span></p><p class="s4" style="padding-left: 109pt;text-indent: 0pt;line-height: 8pt;text-align: left;">nibble)</p><p class="s4" style="padding-top: 3pt;padding-left: 65pt;text-indent: 0pt;line-height: 72%;text-align: justify;"><span class="s62">wire</span> <span class="s63">[</span>3:OJ <span class="s64">XPowerl_A</span> XPowerl[ 7:4J ; <span class="s62">wire</span> <span class="s63">[</span>3:OJ <span class="s64">XPowerl_B</span> XPower1[ 3:0J ; <span class="s62">wire  </span> <span class="s63">[</span>3:OJ <span class="s45">Xl_A      </span> Xl [7:4J ;</p><p class="s4" style="padding-left: 65pt;text-indent: 0pt;line-height: 9pt;text-align: justify;"><span class="s62">wire  </span> <span class="s63">[</span>3:OJ <span class="s45">Xl_B      </span> Xl [3:OJ ;</p><p class="s4" style="padding-left: 66pt;text-indent: 0pt;line-height: 71%;text-align: justify;"><span class="s62">wire</span> <span class="s63">[</span>3:OJ <span class="s64">XPower2_A</span> XPower2[ 7:4J ; <span class="s62">wire</span> <span class="s63">[</span>3:OJ <span class="s64">XPower2_B</span> XPower2[ 3:0J ; <span class="s62">wire  </span> <span class="s63">[</span>3:OJ <span class="s45">X2_A      </span> X2 [7:4J ;</p><p class="s4" style="padding-left: 66pt;text-indent: 0pt;line-height: 11pt;text-align: justify;"><span class="s62">wire  </span> <span class="s63">[</span>3:OJ <span class="s45">X2_B      </span> X2 [3 :O J ;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s65" style="text-indent: 0pt;text-align: right;">I &#39;,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s18" style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Figure 1.6   <span class="s5">Multiplier with separated stages.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 15pt;text-align: justify;">By breaking the multiply operation down into smaller operations that can execute in parallel, the maximum delay is reduced to the longest delay through any of the substructures.</p><p class="s1" style="padding-top: 6pt;padding-left: 57pt;text-indent: 0pt;text-align: left;">Separating a logic function into a number of smaller functions that can be</p><p class="s57" style="padding-top: 2pt;padding-left: 67pt;text-indent: 0pt;text-align: left;">I I <span class="s4">assemble partial assign XPower2</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 68pt;text-indent: 0pt;text-align: left;">assign XPower</p><p style="text-indent: 0pt;text-align: left;"><span><img width="9" height="46" alt="image" src="1 AdvancedFPGADesign_ch1/Image_018.gif"/></span></p><p class="s4" style="padding-top: 2pt;padding-left: 3pt;text-indent: 0pt;line-height: 9pt;text-align: left;">products</p><p class="s4" style="padding-left: 29pt;text-indent: 0pt;line-height: 9pt;text-align: left;">(XPower2_ppAA <span class="s30">&lt;&lt;  </span>8)+</p><p class="s4" style="padding-left: 30pt;text-indent: 0pt;line-height: 107%;text-align: left;">(2*XPower2_ppAB <span class="s30">&lt;&lt;   </span>4)+ XPower2_ppBB; (XPower3_ppAA <span class="s30">&lt;&lt;  </span>8)+</p><p class="s4" style="padding-left: 29pt;text-indent: 1pt;line-height: 112%;text-align: left;">(2*XPower3_ppAB <span class="s30">&lt;&lt;  </span>4)+ XPower3_ppBB;</p><p class="s1" style="padding-left: 57pt;text-indent: 0pt;line-height: 8pt;text-align: left;">evaluated in parallel reduces the path delay to the longest of the substuctures.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li style="padding-left: 77pt;text-indent: -35pt;text-align: justify;"><p class="s40" style="display: inline;">Flatten Logic Structures</p></li></ol></ol></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: justify;">The third strategy for architectural timing improvements is to flatten logic structures. This is closely related to the idea of parallel structures defined in the previous section but applies specifically to logic that is chained due to priority encoding. Typically,</p><p class="s4" style="padding-left: 80pt;text-indent: -10pt;line-height: 7pt;text-align: left;">always @(posedge elk) begin</p><p class="s4" style="padding-top: 4pt;padding-left: 79pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s57">I I </span>pipeline stage 1 Xl           <span class="s66">&lt;= </span>X;</p><p class="s4" style="padding-left: 81pt;text-indent: -1pt;text-align: left;">XPowerl      <span class="s67">&lt;=</span><span class="s66"> </span>X;</p><p class="s4" style="padding-top: 3pt;padding-left: 80pt;text-indent: 0pt;line-height: 9pt;text-align: left;"><span class="s57">I I </span>pipeline stage 2 X2           <span class="s66">&lt;= </span>Xl;</p><p class="s4" style="padding-left: 81pt;text-indent: 0pt;line-height: 88%;text-align: left;"><span class="s57">I I </span>create partial products XPower<span class="s64">2</span>_ppAA <span class="s66">&lt;= </span>XPowerl_A * Xl_A; XPower<span class="s64">2</span>_ppAB <span class="s66">&lt;= </span>XPowerl_A * Xl_B; XPower2_ppBB <span class="s66">&lt;= </span>XPowerl_B * Xl_B;</p><p class="s57" style="padding-top: 5pt;padding-left: 83pt;text-indent: 0pt;line-height: 10pt;text-align: left;">I I <span class="s4">Pipeline stage 3</span></p><p class="s57" style="padding-left: 82pt;text-indent: 0pt;line-height: 10pt;text-align: left;">I I <span class="s4">create partial products</span></p><p class="s4" style="padding-top: 1pt;padding-left: 83pt;text-indent: 0pt;line-height: 75%;text-align: left;">XPower3_ppAA <span class="s66">&lt;= </span>XPower2_A * X2_A; XPower3_ppAB <span class="s66">&lt;= </span>XPower2_A <span class="s68">* </span>X2_B;</p><p class="s4" style="padding-left: 74pt;text-indent: 8pt;text-align: left;">XPower3_ppBB <span class="s66">&lt;= </span>XPower2_B * X2_B;</p><p class="s4" style="padding-top: 3pt;padding-left: 64pt;text-indent: 9pt;text-align: left;">end en&amp;nodule</p><p style="padding-top: 4pt;padding-left: 49pt;text-indent: 0pt;line-height: 107%;text-align: justify;">This design does not take into consideration any overflow issues, but it erves to illustrate the point. The multiplier was broke dwn into smaller functions that could be operated on independently as shown m Figure 1.6.</p><p style="padding-left: 49pt;text-indent: 0pt;text-align: justify;">synthesis and layout tools are smart enough to duplicate logic to reduce fanout, but they are not smart enough to break up logic structures that are coded in a serial fashion, nor do they have enough information relating to the priority requirements of the design. For instance, consider the following control signals coming from an address decode that are used to write four registers:</p><p class="s4" style="padding-top: 6pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">module regwrite(</p><p class="s4" style="padding-left: 75pt;text-indent: 0pt;text-align: left;">output reg [3:0J rout, input            elk, in, input      [3:0J ctrl);</p><p class="s4" style="padding-top: 5pt;padding-left: 75pt;text-indent: 0pt;text-align: left;">always @(posedge elk)</p><p class="s4" style="padding-left: 84pt;text-indent: 0pt;text-align: justify;">if(ctrl[OJ ) rout[OJ <span class="s66">&lt;= </span><span class="s69">in; </span>else if(ctrl[l]) rout[l] <span class="s66">&lt;= </span><span class="s69">in; </span>else if(ctrl[2J ) rout[2] <span class="s66">&lt;= </span><span class="s69">in; </span>else if(ctrl[3J ) rout[3] <span class="s66">&lt;= </span>in;</p><p class="s4" style="padding-top: 1pt;padding-left: 65pt;text-indent: 0pt;text-align: left;">en&amp;nodule</p><p class="s37" style="padding-top: 4pt;padding-left: 49pt;text-indent: 0pt;text-align: justify;">In <span class="p">the above example, each of the control signals are coded with a priority rela­ tive to the other control signals. This type of priority encoding is implemented as shown in Figure 1.7.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 3pt;text-align: left;"><span><img width="503" height="4" alt="image" src="1 AdvancedFPGADesign_ch1/Image_019.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="388" height="225" alt="image" src="1 AdvancedFPGADesign_ch1/Image_020.png"/></span></p><p class="s30" style="padding-top: 6pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">elk   -:;,,----------------,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l10"><ol id="l11"><li style="padding-top: 6pt;padding-left: 63pt;text-indent: -11pt;text-align: left;"><p class="s1" style="display: inline;">Timing     <span class="s12">11</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="12" height="85" alt="image" src="1 AdvancedFPGADesign_ch1/Image_021.gif"/></span></p><p class="s12" style="padding-top: 3pt;padding-left: 115pt;text-indent: 0pt;text-align: left;">12    <span class="s1">Chapter 1   Architecting Speed</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-left: 199pt;text-indent: 0pt;line-height: 9pt;text-align: left;">-.......-........&quot;&quot;&#39;! <span class="s46">D[3:0]    0[3:0] </span><span class="s65">,,.,.m   L.===-­</span></p><p class="s35" style="text-indent: 0pt;line-height: 5pt;text-align: right;">E</p><p style="text-indent: 0pt;text-align: left;"><span><img width="9" height="67" alt="image" src="1 AdvancedFPGADesign_ch1/Image_022.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="315" height="263" alt="image" src="1 AdvancedFPGADesign_ch1/Image_023.png"/></span></p><p class="s8" style="padding-top: 4pt;text-indent: 0pt;text-align: right;">elk</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s36" style="text-indent: 0pt;line-height: 7pt;text-align: right;">[3:0]1r::-::-c=.,.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="12" height="0" alt="image" src="1 AdvancedFPGADesign_ch1/Image_024.png"/></span></p><p class="s36" style="text-indent: 0pt;line-height: 9pt;text-align: right;">[<span class="s70">3</span>:0]       <u>rout[3:0]</u></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s18" style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">Figure 1.7   <span class="s36">Priority encoding.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s3" style="padding-top: 4pt;padding-left: 39pt;text-indent: 16pt;text-align: justify;">If <span class="p">the control lines are strobes from an address decoder in another module, then each strobe is mutually exclusive to the others as they all represent a unique address. However, here we have coded this as if it were a priority decision. Due to the nature of the control signals, the above code will operate exactly as if it were coded in a parallel fashion, but it is unlikely the synthesis tool will be smart enough to recognize that, particularly if the address decode takes place behind another layer of registers.</span></p><p style="padding-left: 39pt;text-indent: 15pt;text-align: justify;">To remove the priority and thereby flatten the logic, we can code this module as shown below:</p><p class="s4" style="padding-top: 8pt;padding-left: 54pt;text-indent: 0pt;text-align: left;">module regwrite(</p><p class="s4" style="padding-left: 65pt;text-indent: 0pt;line-height: 109%;text-align: left;">output reg [3:0] rout, input            elk, in, input      [3:0] etrl);</p><p class="s4" style="padding-top: 5pt;padding-left: 75pt;text-indent: -9pt;line-height: 111%;text-align: left;">always @(posedge elk) begin if(etrl[O] ) rout[O] <span class="s30">&lt;=  </span>in;</p><p class="s4" style="padding-left: 75pt;text-indent: 0pt;line-height: 9pt;text-align: left;">if(etrl[l]) rout[l] <span class="s30">&lt;=  </span>in;</p><p class="s4" style="padding-left: 75pt;text-indent: 0pt;text-align: left;">if(etrl[2]) rout[2] <span class="s30">&lt;=  </span>in;</p><p class="s4" style="padding-left: 65pt;text-indent: 10pt;line-height: 107%;text-align: left;">if (etrl[3]) rout[3] <span class="s30">&lt;=  </span>in; end</p><p class="s4" style="padding-left: 55pt;text-indent: 0pt;text-align: left;">endmodule</p><p style="padding-top: 6pt;padding-left: 38pt;text-indent: 16pt;text-align: justify;">As can be seen in the gate-level implementation, no priority logic is used as shown in Figure 1.8. Each of the control signals acts independently and controls its corresponding rout bits independently.</p><p class="s1" style="padding-top: 6pt;padding-left: 54pt;text-indent: 0pt;line-height: 107%;text-align: left;">By removing priority encodings where they are not needed, the logic structure is flattened and the path delay is reduced.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s72" style="padding-left: 38pt;text-indent: 3pt;text-align: left;">I</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s72" style="padding-left: 38pt;text-indent: 0pt;text-align: left;">I</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 150pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="77" height="56" alt="image" src="1 AdvancedFPGADesign_ch1/Image_025.gif"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s18" style="padding-left: 93pt;text-indent: 0pt;text-align: justify;">Figure 1.8  <span class="s36">No priority encoding.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l12"><li style="padding-left: 128pt;text-indent: -35pt;text-align: justify;"><p class="s40" style="display: inline;">Register Balancing</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 90pt;text-indent: 1pt;text-align: justify;">The fourth strategy is called register balancing. Conceptually, the idea is to redis­ tribute logic evenly between registers to minimize the worst-case delay between any two registers. This technique should be used whenever logic is highly imbal­ anced between the critical path and an adjacent path. Because the clock speed is</p><p style="padding-top: 1pt;padding-left: 90pt;text-indent: 0pt;line-height: 9pt;text-align: justify;">limited by only the worst-case path, it may only take one small change to success­ fully rebalance the critical logic.</p><p style="padding-top: 2pt;padding-left: 89pt;text-indent: 17pt;text-align: justify;">Many synthesis tools also have an optimization called register balancing. This feature will essentially recognize specific structures and reposition registers around logic in a predetermined fashion. This can be useful for common structures such as large multipliers but is limited and will not change your logic nor recognize custom functionality. Depending on the technology, it may require more expensive synthesis tools to implement. Thus, it is very important to understand this concept and have the ability to redistribute logic in custom logic structures.</p><h4 style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">r</h4><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="text-indent: 0pt;text-align: right;">1.3 Timing    <span class="s12">13</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="22" height="234" alt="image" src="1 AdvancedFPGADesign_ch1/Image_026.png"/></span></p><p class="s12" style="padding-top: 6pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">14    <span class="s1">Chapter 1   Architecting Speed</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 103pt;text-indent: -9pt;line-height: 106%;text-align: left;">always @(posedge elk) begin rABSum <span class="s66">&lt;= </span>A <span class="s30">+  </span>B;</p><p style="text-indent: 0pt;text-align: left;"><span><img width="384" height="182" alt="image" src="1 AdvancedFPGADesign_ch1/Image_027.gif"/></span></p><p class="s4" style="padding-left: 509pt;text-indent: 0pt;line-height: 109%;text-align: left;">re Sum</p><p class="s4" style="padding-left: 489pt;text-indent: 10pt;line-height: 109%;text-align: left;">end endmodule</p><p class="s66" style="padding-left: 8pt;text-indent: 0pt;text-align: left;">&lt;= <span class="s4">e;</span></p><p class="s4" style="padding-top: 1pt;padding-left: 8pt;text-indent: 0pt;text-align: left;"><span class="s73">&lt;=</span><span class="s66"> </span>rABSum <span class="s30">+  </span>re;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 472pt;text-indent: 0pt;text-align: justify;">We have now moved one of the add operations back one stage between the input and the first register stage. This balances the logic between the pipeline stages and reduces the critical path as shown in Figure 1.10.</p><p class="s1" style="padding-top: 6pt;padding-left: 488pt;text-indent: 0pt;text-align: left;">Register balancing improves timing by moving combinatorial logic from the critical path to an adjacent path.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s18" style="padding-top: 6pt;text-indent: 0pt;text-align: center;">Figure 1.9   <span class="s5">Registered adder.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 43pt;text-indent: 0pt;text-align: left;">Note the following code for an adder that adds three 8-bit inputs:</p><p class="s4" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">module adder(</p><p class="s4" style="padding-left: 53pt;text-indent: 0pt;line-height: 109%;text-align: left;">output reg [7:0] Sum, input      [7:0] A, B, e,</p></li><li style="padding-top: 3pt;padding-left: 64pt;text-indent: -35pt;text-align: justify;"><p class="s40" style="display: inline;">Reorder Paths</p></li></ol></li></ol></ol><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 26pt;text-indent: 0pt;text-align: justify;">The fifth strategy is to reorder the paths in the data flow to minimize the critical path. This technique should be used whenever multiple paths combine with the critical path, and the combined path can be reordered such that the critical path can be moved closer to the destination register. With this strategy, we will only be concerned with the logic paths between any given set of registers. Consider the following module:</p><p class="s4" style="padding-left: 53pt;text-indent: 0pt;line-height: 109%;text-align: left;">input reg</p><p class="s4" style="padding-left: 26pt;text-indent: 0pt;text-align: center;">elk);</p><p class="s4" style="padding-left: 29pt;text-indent: 0pt;text-align: center;">[7:0] rA, rB, re;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 53pt;text-indent: 0pt;text-align: left;">module randomlogie(</p><p class="s4" style="padding-top: 4pt;padding-left: 63pt;text-indent: -9pt;line-height: 10pt;text-align: left;">always @(posedge elk) begin rA  <span class="s66">&lt;= </span>A;</p><p class="s4" style="padding-left: 53pt;text-indent: 0pt;line-height: 111%;text-align: left;">output reg [7:0] Out, input      [7:0] A, B, e,</p><p class="s4" style="padding-left: 63pt;text-indent: 0pt;text-align: left;">rB  <span class="s66">&lt;= </span>B;</p><p class="s4" style="padding-left: 62pt;text-indent: 0pt;line-height: 8pt;text-align: left;">re  <span class="s66">&lt;= </span>e;</p><p class="s4" style="text-indent: 0pt;line-height: 5pt;text-align: right;">input</p><p class="s4" style="text-indent: 0pt;text-align: right;">input</p><p class="s4" style="padding-left: 57pt;text-indent: 0pt;line-height: 5pt;text-align: left;">elk,</p><p class="s4" style="padding-top: 1pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">eondl, eond2);</p><p class="s4" style="padding-top: 1pt;padding-left: 53pt;text-indent: 9pt;line-height: 111%;text-align: left;">Sum <span class="s66">&lt;= </span>rA <span class="s66">+ </span>rB <span class="s66">+ </span>re; end</p><p class="s4" style="padding-left: 43pt;text-indent: 0pt;line-height: 9pt;text-align: left;">endmodule</p><p style="padding-top: 7pt;padding-left: 26pt;text-indent: 0pt;text-align: justify;">The first register stage consists of rA, rB, and rC, and the second stage consists of Sum. The logic between stages  1 and  2 is  the  adder  for  all  inputs,  whereas the logic between the input and the first register stage contains no logic (assume the outputs feeding this module are registered) as shown in Figure 1.9.</p><p class="s3" style="padding-left: 26pt;text-indent: 15pt;text-align: justify;">If <span class="p">the critical path is defined through the adder, some of the logic in the criti­ cal path can be moved back a stage, thereby balancing the logic load between the two register  stages. Consider the following modification where one of the add operations is moved back a stage:</span></p><p class="s4" style="padding-left: 47pt;text-indent: -9pt;line-height: 8pt;text-align: left;">always @(posedge elk)</p><p class="s4" style="padding-left: 46pt;text-indent: 0pt;line-height: 109%;text-align: left;">if(eondl) Out <span class="s66">&lt;= </span>A;</p><p class="s4" style="padding-left: 46pt;text-indent: -9pt;line-height: 107%;text-align: left;">else if(eond2 &amp;&amp; (e <span class="s30">&lt;  </span>8)) Out <span class="s66">&lt;= </span>B;</p><p class="s4" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">else</p><p class="s4" style="padding-left: 26pt;text-indent: 19pt;line-height: 119%;text-align: left;">Out <span class="s66">&lt;= </span>e; endmodule</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">module adder(</p><p class="s4" style="padding-left: 52pt;text-indent: 0pt;line-height: 110%;text-align: left;">output reg [7:0] Sum, input      [7:0] A, B, e, input            elk);</p><p class="s4" style="padding-left: 52pt;text-indent: 0pt;line-height: 9pt;text-align: left;">reg       [7:0] rABSum, re;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="404" height="99" alt="image" src="1 AdvancedFPGADesign_ch1/Image_028.gif"/></span></p><p class="s35" style="text-indent: 0pt;text-align: center;">elk</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s18" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">Figure 1.10    <span class="s5">Registers balanced.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s35" style="padding-top: 3pt;padding-left: 14pt;text-indent: 0pt;text-align: left;">Q[7:0]     [7:0]</p><p class="s74" style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">r<span class="s3">,, </span><span class="s75">&#39;</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: center;">@K&gt;</p><p class="s8" style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: center;">B[?:O]   [7:0]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s76" style="text-indent: 0pt;line-height: 12pt;text-align: left;">r</p><p style="text-indent: 0pt;text-align: left;"/><p class="s77" style="padding-top: 1pt;padding-left: 141pt;text-indent: 0pt;text-align: left;">1,</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="6" height="101" alt="image" src="1 AdvancedFPGADesign_ch1/Image_029.gif"/></span></p></li><li style="padding-top: 1pt;padding-left: 17pt;text-indent: -11pt;text-align: left;"><p class="s1" style="display: inline;"><span class="s78">Timing    </span> <span class="p">15                                                      </span><span class="s12">16    </span>Chapter 1   Architecting Speed</p><p style="text-indent: 0pt;text-align: left;"><span><img width="402" height="97" alt="image" src="1 AdvancedFPGADesign_ch1/Image_030.png"/></span></p><p style="padding-top: 7pt;padding-left: 194pt;text-indent: 0pt;line-height: 112%;text-align: left;">attention  to exactly  how  a particular  function  is coded, we can have  a direct impact on timing performance.</p><p class="s1" style="padding-top: 4pt;padding-left: 211pt;text-indent: 0pt;line-height: 112%;text-align: left;">Timing can be improved by reordering paths that are combined with the critical path in such a way that some of the critical path logic is placed closer to the des­ tination register.</p><p class="s7" style="padding-top: 1pt;padding-left: 30pt;text-indent: 0pt;text-align: left;">Figure <span class="s18">1.11   </span><span class="s5">Long critical path.                                                                                                                                                                          </span><span class="s79">1.4   SUMMARY</span><span class="s2"> OF KEY POINTS</span></p><ul id="l13"><li style="padding-top: 4pt;padding-left: 490pt;text-indent: -6pt;line-height: 11pt;text-align: left;"><p style="display: inline;">A high-throughput  architecture is one that maximizes  the number of bits per second that can be processed by a design.</p></li></ul></li></ol></ol><p class="s3" style="padding-left: 30pt;text-indent: 0pt;line-height: 6pt;text-align: justify;">In <span class="p">this case, let us assume the critical path is between C and Out and consists of a</span></p><p style="padding-left: 30pt;text-indent: 0pt;text-align: justify;">comparator in series with two gates before reaching the decision mux. This is shown in Figure 1.11. Assuming the conditions are not mutually exclusive, we can modify the code to reorder the long delay of the comparitor:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 56pt;text-indent: -10pt;line-height: 109%;text-align: left;">module randornlogie( output reg [7:0] Out,</p><p class="s4" style="padding-left: 56pt;text-indent: 0pt;line-height: 109%;text-align: left;">input      [7:0] A, B, C, input           elk,</p><ul id="l14"><li style="padding-top: 3pt;padding-left: 37pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">Unrolling an iterative loop increases throughput.</p></li><li style="padding-top: 2pt;padding-left: 37pt;text-indent: -6pt;line-height: 116%;text-align: left;"><p style="display: inline;">The penalty  for unrolling  an iterative loop is a proportional  increase in area.</p><p style="padding-left: 37pt;text-indent: 0pt;line-height: 110%;text-align: left;">A low-latency architecture is one that minimizes the delay from the input of a module to the output.</p></li><li style="padding-top: 1pt;padding-left: 37pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">Latency can be reduced by removing pipeline registers.</p></li><li style="padding-top: 3pt;padding-left: 37pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">The penalty for removing pipeline registers is an increase in combinatorial</p><p class="s4" style="padding-left: 56pt;text-indent: 0pt;text-align: left;">input</p><p class="s4" style="padding-left: 55pt;text-indent: 0pt;text-align: left;">wire CondB</p><p class="s4" style="padding-left: 14pt;text-indent: 17pt;line-height: 109%;text-align: left;">Condl, Cond2); (Cond2 &amp; !Condl);</p><p style="padding-left: 62pt;text-indent: 0pt;text-align: left;">delay between registers.</p><ul id="l15"><li style="padding-top: 2pt;padding-left: 61pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">Timing refers to the clock speed of a design. A design meets timing when</p><p class="s4" style="padding-left: 66pt;text-indent: -10pt;line-height: 8pt;text-align: left;">always @(posedge elk)</p><p class="s4" style="padding-left: 75pt;text-indent: -9pt;line-height: 109%;text-align: left;">if(CondB &amp;&amp; (C <span class="s30">&lt;  </span>8)) Out <span class="s30">&lt;=  </span>B;</p><p class="s4" style="padding-left: 75pt;text-indent: -9pt;line-height: 109%;text-align: left;">else if(Condl) Out <span class="s30">&lt;=  </span>A;</p><p class="s4" style="padding-left: 65pt;text-indent: 0pt;line-height: 9pt;text-align: left;">else</p><p class="s4" style="padding-left: 45pt;text-indent: 29pt;line-height: 116%;text-align: left;">Out <span class="s30">&lt;=  </span>C·<span class="s3">, </span>endrnodule</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 29pt;text-indent: 0pt;text-align: left;">By reorganizing the code, we have moved one of the gates out of the critical path in series with the comparator as shown in Figure  1.12. Thus, by paying careful</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="366" height="141" alt="image" src="1 AdvancedFPGADesign_ch1/Image_031.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="34" height="1" alt="image" src="1 AdvancedFPGADesign_ch1/Image_032.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="1" height="64" alt="image" src="1 AdvancedFPGADesign_ch1/Image_033.png"/></span></p><p class="s80" style="padding-left: 35pt;text-indent: -3pt;line-height: 115%;text-align: left;">  Cond2<span class="s30"> Cond1</span></p><p style="padding-left: 35pt;text-indent: 0pt;line-height: 112%;text-align: left;">the maximum delay between any two sequential elements is smaller than the minimum clock period.</p></li></ul></li><li style="padding-top: 1pt;padding-left: 35pt;text-indent: -6pt;line-height: 110%;text-align: justify;"><p style="display: inline;">Adding register layers improves timing by dividing the critical path into two paths of smaller delay.</p></li><li style="padding-top: 1pt;padding-left: 35pt;text-indent: -6pt;line-height: 109%;text-align: justify;"><p style="display: inline;">Separating a logic function into a number of smaller functions that can be evaluated in parallel reduces the path delay to the longest  of the substructures.</p></li><li style="padding-top: 1pt;padding-left: 35pt;text-indent: -6pt;line-height: 110%;text-align: justify;"><p style="display: inline;">By removing priority encodings where they are not needed, the logic struc­ ture is flattened, and the path delay is reduced.</p></li><li style="padding-top: 1pt;padding-left: 35pt;text-indent: -6pt;line-height: 108%;text-align: justify;"><p style="display: inline;">Register balancing improves timing by moving combinatorial logic from the critical path to an adjacent path.</p></li><li style="padding-top: 1pt;padding-left: 36pt;text-indent: -6pt;line-height: 107%;text-align: justify;"><p style="display: inline;">Timing can be improved by reordering  paths that are combined with the critical path in such a way that some of the critical path logic is placed closer to the destination register.</p></li></ul><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s30" style="padding-top: 6pt;padding-left: 36pt;text-indent: 0pt;text-align: left;">A[7:0]</p><p class="s30" style="padding-top: 1pt;padding-left: 36pt;text-indent: 0pt;text-align: left;">8[7:0]</p><p class="s30" style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">[7:0]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s30" style="padding-left: 36pt;text-indent: 0pt;text-align: left;">C[7:0]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s30" style="padding-top: 5pt;padding-left: 16pt;text-indent: 0pt;text-align: left;">[7:0]</p><p class="s30" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">[7:0]</p><p class="s30" style="padding-top: 1pt;padding-left: 81pt;text-indent: 0pt;text-align: left;">00001000</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 28pt;text-indent: 0pt;text-align: left;">Figure 1.12    <span class="s5">Logic reordered to reduce critical path.</span></p></body></html>
