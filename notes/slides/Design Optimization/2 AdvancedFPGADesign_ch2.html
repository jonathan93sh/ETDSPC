<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>2 AdvancedFPGADesign_ch2</title><meta name="author" content="phm"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .s1 { color: #231F20; font-family:"Palatino Linotype", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 16.5pt; }
 .s2 { color: #231F20; font-family:"Palatino Linotype", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 27.5pt; }
 .s3 { color: #231F20; font-family:"Palatino Linotype", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 20pt; }
 .s4 { color: #231F20; font-family:"Palatino Linotype", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 15pt; }
 .p, p { color: #231F20; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; margin:0pt; }
 .s5 { color: #231F20; font-family:Garamond, serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s6 { color: #231F20; font-family:"Trebuchet MS", sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s7 { color: #231F20; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s8 { color: #231F20; font-family:ESSTIXThree; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s9 { color: #231F20; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s10 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s11 { color: #231F20; font-family:"OCR A Extended", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s12 { color: #231F20; font-family:"Palatino Linotype", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s13 { color: #231F20; font-family:"Gill Sans MT", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s14 { color: #231F20; font-family:"Palatino Linotype", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s15 { color: #231F20; font-family:Garamond, serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 6.5pt; }
 .s16 { color: #231F20; font-family:Century, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s17 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s18 { color: #231F20; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s19 { color: #231F20; font-family:"OCR A Extended", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s21 { color: #231F20; font-family:"Tw Cen MT", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s22 { color: #231F20; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s23 { color: #231F20; font-family:Calibri, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s24 { color: #231F20; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 7.5pt; }
 .s25 { color: #231F20; font-family:Verdana, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s26 { color: #231F20; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s27 { color: #231F20; font-family:"Lucida Sans Unicode", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s28 { color: #231F20; font-family:Garamond, serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9pt; }
 .s29 { color: #231F20; font-family:"Lucida Sans Unicode", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s30 { color: #231F20; font-family:"Century Gothic", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s31 { color: #231F20; font-family:Tahoma, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li:before {content: "● "; color: #231F20; font-family:SimSun; font-style: normal; font-weight: normal; text-decoration: none; font-size: 3.5pt; vertical-align: 1pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 2; }
 #l2> li:before {counter-increment: d1; content: counter(d1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l3 {padding-left: 0pt;counter-reset: d2 4; }
 #l3> li:before {counter-increment: d2; content: counter(d1, decimal)"."counter(d2, decimal)" "; color: #231F20; font-family:Century, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 9pt; }
 #l4 {padding-left: 0pt; }
 #l4> li:before {content: "● "; color: #231F20; font-family:SimSun; font-style: normal; font-weight: normal; text-decoration: none; font-size: 3.5pt; vertical-align: 1pt; }
 li {display: block; }
 #l5 {padding-left: 0pt; }
 #l5> li:before {content: "● "; color: #231F20; font-family:SimSun; font-style: normal; font-weight: normal; text-decoration: none; font-size: 3.5pt; vertical-align: 1pt; }
 table, tbody {vertical-align: top; overflow: visible; }
</style></head><body><p class="s1" style="padding-left: 20pt;text-indent: -15pt;line-height: 34pt;text-align: left;">Chapter <span class="s2">2</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="381" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_001.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s3" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">Architecting Area</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s4" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">T<span class="p">his chapter discusses the second of three primary physical characteristics of a digital design: area. Here we also discuss methods for architectural area optimization in an FPGA.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">We will discuss area reduction based on choosing the correct topology. Topology refers to the higher-level organization of the design and is not device specific. Circuit-level reduction as performed by the synthesis and layout tools refers to the minimization of the number of gates in a subset of the design and may be device specific.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">A topology that targets area is one that reuses the logic resources to the greatest extent possible, often at the expense of throughput (speed). Very often this requires a recursive data flow, where the output of one stage is fed back to the input for similar processing. This can be a simple loop that flows naturally with the algorithm or it may be that the logic reuse is complex and requires special controls. This section describes both techniques and describes the necess- ary consequences in terms of performance penalties.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">During the course of this chapter, we will discuss the following topics in detail:</p><ul id="l1"><li style="padding-top: 5pt;padding-left: 26pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">Rolling up the pipeline to reuse logic resources in different stages of a computation.</p></li><li style="padding-top: 2pt;padding-left: 26pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">Controls to manage the reuse of logic when a natural flow does not exist.</p></li><li style="padding-top: 2pt;padding-left: 26pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">Sharing logic resources between different functional operations.</p></li><li style="padding-top: 2pt;padding-left: 26pt;text-indent: -6pt;line-height: 10pt;text-align: left;"><p style="display: inline;">The impact of reset on area optimization.</p></li></ul><p style="padding-left: 35pt;text-indent: 0pt;text-align: left;">Impact of FPGA resources that lack reset capability. Impact of FPGA resources that lack set capability.</p><p style="padding-left: 35pt;text-indent: 0pt;text-align: left;">Impact of FPGA resources that lack asynchronous reset capability. Impact of RAM reset.</p><p style="padding-left: 35pt;text-indent: 0pt;text-align: left;">Optimization using set<span class="s5">/</span>reset pins for logic implementation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="81" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_002.png"/></span></p><p class="s7" style="padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s6">Advanced FPGA Design</span>. By Steve Kilts Copyright <span class="s8"># </span>2007 John Wiley &amp; Sons, Inc.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">18    <span class="s9">Chapter 2    Architecting Area</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">2.1   ROLLING UP THE PIPELINE</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">The method of “rolling up the pipeline” is the opposite operation to that described in the previous chapter to improve throughput by “unrolling the loop” to achieve maximum performance. When we unrolled the loop to create a pipeline, we also increased the area by requiring more resources to hold intermediate values and replicating computational structures that needed to run in parallel. Conversely, when we want to minimize the area of a design, we must perform these operations in reverse; that is, roll up the pipeline so that logic resources can be reused. Thus, this method should be used when optimizing highly pipelined designs with duplicate logic in the pipeline stages.</p><p class="s9" style="padding-top: 6pt;padding-left: 20pt;text-indent: 0pt;line-height: 107%;text-align: left;">Rolling up the pipeline can optimize the area of pipelined designs with duplicated logic in the pipeline stages.</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 15pt;text-align: justify;">Consider the example of a fixed-point fractional multiplier. In this example, A is represented in normal integer format with the fixed point just to the right of the LSB, whereas the input B has a fixed point just to the left of the MSB. In other words, B scales A from 0 to 1.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">module mult8(</p><p class="s11" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">output [7:0]  product,</p><p class="s11" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">input  [7:0]  A,</p><p class="s11" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;line-height: 119%;text-align: left;">input  [7:0]  B, input         clk);</p><p class="s11" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">reg    [15:0] prod16;</p><p class="s11" style="padding-left: 24pt;text-indent: 0pt;line-height: 14pt;text-align: left;">assign product = prod16[15:8]; always @(posedge clk)</p><p class="s11" style="padding-top: 1pt;padding-left: 20pt;text-indent: 13pt;line-height: 185%;text-align: left;">prod16 &lt;= A * B; endmodule</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">With this implementation, a new product is generated on every clock. There isn’t an obvious pipeline in this design as far as distinct sets of registers, but note that the mul- tiplier itself is a fairly long chain of logic that is easily pipelined by adding intermedi- ate register layers. It is this multiplier that we wish to “roll up.” We will roll this up by performing the multiply with a series of shift and add operations as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">module mult8(</p><p class="s11" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;line-height: 119%;text-align: left;">output           done, output reg [7:0] product, input      [7:0] A,</p><p class="s11" style="padding-left: 24pt;text-indent: 0pt;text-align: left;">input      [7:0] B,</p><p class="s11" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">input            clk,</p><p class="s11" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">input            start);</p><p class="s11" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">reg        [4:0] multcounter; // counter for number of</p><p class="s11" style="padding-top: 1pt;padding-left: 176pt;text-indent: 0pt;text-align: left;">shift/adds</p><p class="s12" style="padding-top: 6pt;text-indent: 0pt;text-align: center;">17</p><p class="s9" style="padding-top: 3pt;padding-left: 185pt;text-indent: 0pt;text-align: left;">2.1 Rolling Up the Pipeline     <span class="s12">19</span></p><p class="s13" style="padding-top: 4pt;padding-left: 120pt;text-indent: 0pt;text-align: left;">20    <span class="s9">Chapter 2    Architecting Area</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 25pt;text-indent: 0pt;line-height: 119%;text-align: left;">reg        [7:0] shiftB; // shift register for B reg        [7:0] shiftA; // shift register for A</p><p class="s11" style="padding-top: 5pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">wire adden; // enable addition</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 25pt;text-indent: 0pt;line-height: 120%;text-align: left;">assign adden = shiftB[7] &amp; !done; assign done = multcounter[3];</p><p class="s11" style="padding-top: 4pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">always @(posedge clk) begin</p><p class="s11" style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;line-height: 119%;text-align: left;">// increment   multiply counter for shift/add ops if(start)      multcounter &lt;= 0;</p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">else if(!done) multcounter &lt;= multcounter + 1;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;line-height: 119%;text-align: left;">// shift register for B if(start) shiftB &lt;= B;</p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">else shiftB[7:0] &lt;= {shiftB[6:0], 1’b0};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;line-height: 119%;text-align: left;">// shift register for A if(start) shiftA &lt;= A;</p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">else shiftA[7:0] &lt;= {shiftA[7], shiftA[7:1]};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;line-height: 119%;text-align: left;">// calculate multiplication if(start)      product &lt;= 0;</p><p class="s11" style="padding-left: 25pt;text-indent: 9pt;line-height: 119%;text-align: left;">else if(adden) product &lt;= product + shiftA; end</p><p class="s11" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">endmodule</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">The multiplier is thus architected with an accumulator that adds a shifted version of A depending on the bits of B as shown in Figure 2.1. Thus, we comple- tely eliminate the logic tree necessary to generate a multiply within a single clock and replace it with a few shift registers and an adder. This is a very compact form of a multiplier but will now require 8 clocks to complete a multiplication. Also note that no special controls were necessary to sequence through this multiply operation. We simply relied on a counter to tell us when to stop the shift and add operations. The next section describes situations where this control is  not  so trivial.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="374" height="128" alt="image" src="2 AdvancedFPGADesign_ch2/Image_003.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s14">Figure 2.1    </span>Shift<span class="s15">/</span>add multiplier.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s16" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">2.2  CONTROL-BASED LOGIC REUSE</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Sharing logic resources oftentimes requires special control circuitry to determine which elements are input to the particular structure. In the previous section, we described a multiplier that simply shifted the bits of each register, where each reg- ister was always dedicated to a particular input of the running adder. This had a natural data flow that lent itself well to logic reuse. In other applications, there are often more complex variations to the input of a resource, and certain controls may be necessary to reuse the logic.</p><p class="s9" style="padding-top: 5pt;padding-left: 20pt;text-indent: 0pt;line-height: 107%;text-align: left;">Controls can be used to direct the reuse of logic when the shared logic is larger than the control logic.</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 15pt;text-align: left;">To determine this variation, a state machine may be required as an additional input to the logic.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: left;">Consider the following example of a low-pass FIR filter represented by the equation:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 46pt;text-indent: 0pt;text-align: center;">Y <span class="s17">¼ </span>coeffA <span class="s17">* </span>X<span class="s17">½</span>0<span class="s17">] þ </span>coeffB <span class="s17">* </span>X<span class="s17">½</span>1<span class="s17">] þ </span>coeffC <span class="s17">* </span>X<span class="s17">½</span>2<span class="s17">]</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">module lowpassfir(</p><p class="s11" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;line-height: 119%;text-align: left;">output reg [7:0] filtout, output reg       done,</p><p class="s11" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">input            clk,</p><p class="s11" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">input      [7:0] datain, // X[0]</p><p class="s11" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">input            datavalid, // X[0] is valid</p><p class="s11" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">input      [7:0] coeffA, coeffB; coeffC); // coeffs for</p><p class="s11" style="padding-top: 1pt;padding-left: 231pt;text-indent: 0pt;line-height: 119%;text-align: left;">low pass filter</p><p class="s11" style="padding-left: 25pt;text-indent: 0pt;line-height: 119%;text-align: left;">// define input/output samples reg        [7:0] X0, X1, X2;</p><p class="s11" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">reg              multdonedelay;</p><p class="s11" style="padding-top: 1pt;padding-left: 167pt;text-indent: -142pt;line-height: 119%;text-align: left;">reg              multstart; // signal to multiplier to begin computation</p><p class="s11" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">reg        [7:0] multdat;</p><p class="s11" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">reg        [7:0] multcoeff; // the registers that are</p><p class="s11" style="padding-top: 1pt;padding-left: 25pt;text-indent: 142pt;line-height: 119%;text-align: left;">multiplied together reg        [2:0] state; // holds state for sequencing</p><p class="s11" style="padding-left: 149pt;text-indent: 0pt;text-align: left;">through mults</p><p class="s11" style="padding-top: 1pt;padding-left: 24pt;text-indent: 0pt;line-height: 119%;text-align: justify;">reg      [7:0] accum; // accumulates multiplier products reg                     clearaccum; // sets accum to zero reg        [7:0] accumsum;</p><p class="s11" style="padding-left: 24pt;text-indent: 0pt;line-height: 119%;text-align: left;">wire             multdone; // multiplier has completed wire       [7:0] multout; // multiplier product</p><p class="s11" style="padding-top: 5pt;padding-left: 25pt;text-indent: 0pt;line-height: 111%;text-align: left;">// shift-add multiplier for sample-coeff mults mult8 <span class="s18">x </span>8 mult8 <span class="s18">x </span>8(.clk(clk), .dat1(multdat),</p><p class="s11" style="padding-left: 24pt;text-indent: 0pt;text-align: center;">.dat2(multcoeff), .start(multstart),</p><p class="s11" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;text-align: center;">.done(multdone), .multout(multout));</p><p class="s18" style="padding-top: 4pt;padding-left: 174pt;text-indent: 0pt;text-align: left;">2.2 Control-Based Logic Reuse  <span class="s13">21</span></p><p class="s12" style="padding-top: 3pt;padding-left: 120pt;text-indent: 0pt;text-align: left;">22    <span class="s9">Chapter 2    Architecting Area</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 4pt;padding-left: 33pt;text-indent: -7pt;line-height: 119%;text-align: left;">always @(posedge clk) begin multdonedelay &lt;= multdone;</p><p class="s11" style="padding-top: 5pt;padding-left: 26pt;text-indent: 0pt;line-height: 119%;text-align: left;">// accumulates sample-coeff products accumsum &lt;= accum + multout[7:0];</p><p class="s11" style="padding-top: 5pt;padding-left: 26pt;text-indent: 0pt;line-height: 119%;text-align: left;">// clearing and loading accumulator if(clearaccum)         accum &lt;= 0;</p><p class="s11" style="padding-left: 26pt;text-indent: 0pt;text-align: left;">else if(multdonedelay) accum &lt;= accumsum;</p><p class="s11" style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;line-height: 119%;text-align: left;">// do not process state machine if multiply is not done case(state)</p><p class="s11" style="padding-left: 30pt;text-indent: 0pt;text-align: left;">0: begin</p><p class="s11" style="padding-top: 1pt;padding-left: 30pt;text-indent: 0pt;line-height: 119%;text-align: left;">// idle state if(datavalid) begin</p><p class="s11" style="padding-left: 35pt;text-indent: 0pt;text-align: left;">// if a new sample has arrived</p><p class="s11" style="padding-top: 1pt;padding-left: 35pt;text-indent: 0pt;line-height: 119%;text-align: left;">// shift samples X0     &lt;= datain;</p><p class="s11" style="padding-left: 35pt;text-indent: 0pt;text-align: left;">X1     &lt;= X0;</p><p class="s11" style="padding-top: 1pt;padding-left: 35pt;text-indent: 0pt;text-align: left;">X2     &lt;= X1;</p><p class="s11" style="padding-top: 1pt;padding-left: 35pt;text-indent: 0pt;line-height: 119%;text-align: left;">multdat  &lt;= datain;   // load mult multcoeff &lt;= coeffA;</p><p class="s11" style="padding-left: 35pt;text-indent: 0pt;text-align: left;">multstart &lt;= 1;</p><p class="s11" style="padding-top: 1pt;padding-left: 35pt;text-indent: 0pt;line-height: 119%;text-align: left;">clearaccum &lt;= 1; // clear accum state   &lt;= 1;</p><p class="s11" style="padding-left: 30pt;text-indent: 0pt;text-align: left;">end</p><p class="s11" style="padding-top: 1pt;padding-left: 35pt;text-indent: -4pt;line-height: 119%;text-align: left;">else begin multstart &lt;= 0;</p><p class="s11" style="padding-left: 35pt;text-indent: 0pt;text-align: left;">clearaccum &lt;= 0;</p><p class="s11" style="padding-top: 1pt;padding-left: 30pt;text-indent: 4pt;line-height: 119%;text-align: left;">done    &lt;= 0; end</p><p class="s11" style="padding-left: 30pt;text-indent: 0pt;text-align: left;">end</p><p class="s11" style="padding-top: 1pt;padding-left: 30pt;text-indent: 0pt;line-height: 119%;text-align: left;">1: begin if(multdonedelay) begin</p><p class="s11" style="padding-left: 35pt;text-indent: 0pt;line-height: 119%;text-align: left;">// A*X[0] is done, load B*X[1] multdat  &lt;= X1;</p><p class="s11" style="padding-left: 35pt;text-indent: 0pt;line-height: 119%;text-align: left;">multcoeff &lt;= coeffB; multstart &lt;= 1;</p><p class="s11" style="padding-left: 30pt;text-indent: 4pt;line-height: 119%;text-align: left;">state   &lt;= 2; end</p><p class="s11" style="padding-left: 35pt;text-indent: -4pt;line-height: 120%;text-align: left;">else begin multstart &lt;= 0;</p><p class="s11" style="padding-left: 35pt;text-indent: 0pt;line-height: 8pt;text-align: left;">clearaccum &lt;= 0;</p><p class="s11" style="padding-top: 1pt;padding-left: 30pt;text-indent: 4pt;line-height: 119%;text-align: left;">done    &lt;= 0; end</p><p class="s11" style="padding-left: 30pt;text-indent: 0pt;text-align: left;">end</p><p class="s11" style="padding-top: 1pt;padding-left: 30pt;text-indent: 0pt;line-height: 119%;text-align: left;">2: begin if(multdonedelay) begin</p><p class="s11" style="padding-left: 35pt;text-indent: 0pt;line-height: 119%;text-align: left;">// B*X[1] is done, load C*X[2] multdat  &lt;= X2;</p><p class="s11" style="padding-top: 4pt;padding-left: 34pt;text-indent: 0pt;line-height: 119%;text-align: left;">multcoeff &lt;= coeffC; multstart &lt;= 1;</p><p class="s11" style="padding-left: 29pt;text-indent: 4pt;line-height: 119%;text-align: left;">state   &lt;= 3; end</p><p class="s11" style="padding-left: 34pt;text-indent: -4pt;line-height: 119%;text-align: left;">else begin multstart &lt;= 0;</p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">clearaccum &lt;= 0;</p><p class="s11" style="padding-top: 1pt;padding-left: 29pt;text-indent: 4pt;line-height: 119%;text-align: left;">done    &lt;= 0; end</p><p class="s11" style="padding-left: 29pt;text-indent: 0pt;text-align: left;">end</p><p class="s11" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 119%;text-align: left;">3: begin if(multdonedelay) begin</p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;line-height: 119%;text-align: left;">// C*X[2] is done, load output filtout  &lt;= accumsum;</p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">done    &lt;= 1;</p><p class="s11" style="padding-top: 1pt;padding-left: 29pt;text-indent: 4pt;line-height: 119%;text-align: left;">state   &lt;= 0; end</p><p class="s11" style="padding-left: 34pt;text-indent: -4pt;line-height: 119%;text-align: left;">else begin multstart &lt;= 0;</p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">clearaccum &lt;= 0;</p><p class="s11" style="padding-top: 1pt;padding-left: 29pt;text-indent: 4pt;line-height: 119%;text-align: left;">done    &lt;= 0; end</p><p class="s11" style="padding-left: 29pt;text-indent: 0pt;line-height: 119%;text-align: left;">end default</p><p class="s11" style="padding-left: 25pt;text-indent: 9pt;line-height: 119%;text-align: left;">state   &lt;= 0; endcase</p><p class="s11" style="padding-left: 10pt;text-indent: 5pt;line-height: 119%;text-align: left;">end endmodule</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">In this implementation, only a single multiplier and accumulator are used as can be seen in Figure 2.2. Additionally, a state machine is used to load coefficients and registered samples into the multiplier. The state machine operates on every combination of coefficients and samples: <span class="s19">coeffA*X[0], coeffB*X[1], and coeffC*X[2]</span>.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: left;">The reason this implementation required a state machine is because there was no natural flow to the recursive data as there was with the shift and add multiplier</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="375" height="105" alt="image" src="2 AdvancedFPGADesign_ch2/Image_004.png"/></span></p><p class="s14" style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Figure 2.2    <span class="s7">FIR with one MAC.</span></p><p class="s9" style="padding-top: 1pt;text-indent: 0pt;line-height: 11pt;text-align: right;">2.3 Resource Sharing     <span class="s12">23</span></p><p class="s12" style="padding-top: 1pt;padding-left: 120pt;text-indent: 0pt;line-height: 11pt;text-align: left;">24    <span class="s9">Chapter 2    Architecting Area</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">example. In this case, we had arbitrary registers that represented the inputs required to create a set of products. The most efficient way to sequence through the set of multiplier inputs was with a state machine.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s16" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">2.3  RESOURCE SHARING</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">When we use the term <i>resource sharing</i>, we are not referring to the low-level optimizations performed by FPGA place and route tools (this is discussed in later chapters). Instead, we are referring to higher-level architectural resource sharing where different resources are shared across different functional boundaries. This type of resource sharing should be used whenever there are functional blocks that can be used in other areas of the design or even in different modules.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">A simple example of resource sharing is with system counters. Many designs use multiple counters for timers, sequencers, state machines, and so forth. Often- times, these counters can be pulled to a higher level in the hierarchy and distribu- ted to multiple functional units. For instance, consider modules A and B. Each of these modules uses counters for a different reason. Module A uses the counter to</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="305" height="315" alt="image" src="2 AdvancedFPGADesign_ch2/Image_005.png"/></span></p><p class="s14" style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Figure 2.3    <span class="s7">Separated counters.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="304" height="355" alt="image" src="2 AdvancedFPGADesign_ch2/Image_006.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Figure 2.4    <span class="s7">Shared counter.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">flag an operation every 256 clocks (at 100 MHz, this would correspond with a trigger every 2.56 <span class="s21">m</span>s). Module B uses a counter to generate a PWM (Pulse Width Modulated) pulse of varying duty cycle with a fixed frequency of 5.5 kHz (with a 100-MHz system clock, this would correspond with a period of hex 700 clocks).</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">Each module in Figure 2.3 performs a completely independent operation. The counters in each module also have completely different characteristics. In module A, the counter is 8 bits, free running, and rolls over automatically. In module B, the counter is 11 bits and resets at a predefined value (1666). Nonetheless, these counters can easily be merged into a global timer and used independently by modules A and B as shown in Figure 2.4.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">Here we were able to create a global 11-bit counter that satisfied the require- ment of both module A and module B.</p><p class="s9" style="padding-top: 4pt;padding-left: 20pt;text-indent: 0pt;line-height: 107%;text-align: left;">For compact designs where area is the primary requirement, search for resources that have similar counterparts in other modules that can be brought to a global point in the hierarchy and shared between multiple functional areas.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">2.4  IMPACT OF RESET ON AREA</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">A common misconception is that the reset structures are always implemented in a purely global sense and have little effect on design size. The fact is that there are a number of considerations to take into account relative to area when designing a reset structure and a corresponding number of penalties to pay for a suboptimal design.</p><p style="padding-left: 6pt;text-indent: 15pt;text-align: justify;">The first effect on area has to do with the insistence on defining a global set<span class="s5">/</span>reset condition for every flip-flop. Although this may seem like good design practice, it can often lead to a larger and slower design. The reason for this is because certain functions can be optimized according to the fine-grain architecture of the FPGA, but bringing a reset into every synchronous element can cause the synthesis and mapping tools to push the logic into a coarser implementation.</p><p class="s9" style="padding-top: 6pt;padding-left: 21pt;text-indent: 0pt;line-height: 107%;text-align: left;">An improper reset strategy can create an unnecessarily large design and inhibit certain area optimizations.</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 15pt;text-align: justify;">The next sections describe a number of different scenarios where the reset can play a significant role in the speed<span class="s5">/</span>area characteristics and how to optimize accordingly.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s10" style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">2.4.1   Resources Without Reset</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">This section describes the impact that a global reset will have on FPGA resources that do not have reset available. Consider the following example of a simple shift register:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="379" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_007.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="131" height="11" alt="image" src="2 AdvancedFPGADesign_ch2/Image_008.png"/></span></p><p class="s22" style="padding-top: 1pt;padding-left: 12pt;text-indent: 0pt;text-align: left;">IMPLEMENTATION 1 : <span class="s23">Synchronous Reset</span></p><p class="s11" style="padding-top: 6pt;padding-left: 26pt;text-indent: -4pt;line-height: 119%;text-align: left;">always @(posedge iClk) if(!iReset) sr &lt;= 0;</p><p class="s11" style="padding-left: 12pt;text-indent: 13pt;text-align: left;">else sr        &lt;= {sr[14:0], iDat};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="381" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_009.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="131" height="11" alt="image" src="2 AdvancedFPGADesign_ch2/Image_010.png"/></span></p><p class="s22" style="padding-top: 4pt;padding-left: 12pt;text-indent: 0pt;text-align: left;">IMPLEMENTATION 2 : <span class="s23">No Reset</span></p><p class="s11" style="padding-top: 6pt;padding-left: 21pt;text-indent: 0pt;text-align: left;">always @(posedge iClk)</p><p class="s11" style="padding-top: 1pt;padding-left: 26pt;text-indent: 0pt;text-align: left;">sr &lt;= {sr[14:0], iDat};</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="379" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_011.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">The differences between the above two implementations may seem trivial. In one case, the flip-flops have resets defined to be logic-0, whereas in the other implementation, the flip-flops do not have a defined reset state. The key here is that if we wish to take advantage of built-in shift-register resources available in the FPGA, we will need to code it such that there is a direct mapping. If we were targeting a Xilinx device, the synthesis tool would recognize that the shift-register SRL16 could be used to implement the shift register as shown in Figure 2.5.</p><p style="padding-left: 6pt;text-indent: 15pt;text-align: justify;">Note that no resets are defined for the SRL16 device. If resets are defined in our design, then the SRL16 unit could not be used as there are no reset control</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="372" height="81" alt="image" src="2 AdvancedFPGADesign_ch2/Image_012.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Figure 2.5   <span class="s7">Shift register implemented with SRL16 element.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="374" height="59" alt="image" src="2 AdvancedFPGADesign_ch2/Image_013.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Figure 2.6    <span class="s7">Shift register implemented with flip-flops.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Table 2.1    <span class="s9">Resource Utilization for Shift Register Implementations</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="272" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_014.png"/></span></p><p class="s24" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"> Implementation                         Slices slice                      Flip-flops </p><p class="s9" style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Resets defined                                   9                                    16</p><p class="s9" style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">No resets defined                              1                                      1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="268" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_015.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">signals to the resource. The shift register would be implemented as discrete flip- flops as shown in Figure 2.6. The difference is  drastic  as  summarized  in Table 2.1.</p><p class="s9" style="padding-top: 6pt;padding-left: 21pt;text-indent: 0pt;line-height: 107%;text-align: left;">An optimized FPGA resource will not be used if an incompatible reset is assigned to it. The function will be implemented with generic elements and will occupy more area.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 15pt;text-align: justify;">By removing the reset signals, we were able to reduce 9 slices and 16 slice flip-flops to a single slice and single slice flip-flop. This corresponds with an opti- mally compact and high-speed shift-register implementation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s25" style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">2.4.2   Resources Without Set</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Similar to the problem raised in the previous section, some internal resources lack any type of set capability. An example is that of an 8<span class="s17">x</span>8 multiplier:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 21pt;text-indent: 0pt;text-align: left;">module mult8(</p><p class="s11" style="padding-top: 1pt;padding-left: 30pt;text-indent: 0pt;line-height: 119%;text-align: left;">output reg [15:0] oDat, input       iReset, iClk, input   [7:0] iDat1, iDat2,</p><p class="s11" style="padding-left: 30pt;text-indent: 0pt;text-align: left;">);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="374" height="95" alt="image" src="2 AdvancedFPGADesign_ch2/Image_016.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Figure 2.7   <span class="s7">Set implemented with external logic.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Table 2.2    <span class="s9">Resource Utilization for Set and Reset Implementations</span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="271" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_017.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="271" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_018.png"/></span></p><p class="s9" style="padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: left;">Implementation      Slices slice      Flip-flops      LUTs      Mult16 Reset                               9                    16                1               1</p><p class="s9" style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Set                                   1                      1                1               1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="268" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_019.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-top: 4pt;padding-left: 35pt;text-indent: -9pt;line-height: 119%;text-align: left;">always @(posedge iClk) if(!iReset) oDat &lt;= 16’hffff; else    oDat &lt;= iDat1 * iDat2;</p><p class="s11" style="padding-top: 3pt;padding-left: 21pt;text-indent: 0pt;text-align: left;">endmodule</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Again, the only variation to the above code will be the reset condition. Unlike the shift-register example, the multiplier resources in most FPGAs have built-in reset resources. They do not, however, typically have set resources. If the set function- ality as described above (16’hffff instead of simply 0) is required, the circuit illus- trated in Figure 2.7 will be implemented.</p><p style="padding-left: 6pt;text-indent: 15pt;text-align: justify;">Here an additional gate for each output is required to set the output when the reset is active. The reset on the multiplier, in this case, will go unused. The resource usage between the set and reset implementations is shown in Table 2.2.</p><p style="padding-left: 6pt;text-indent: 15pt;text-align: justify;">By changing the multiplier set to a reset operation, we are able to reduce 9 slices and 16 slice flip-flops to a single slice and single slice flip-flop. This corre- sponds with an optimally compact and high-speed multiplier implementation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s25" style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">2.4.3  Resources Without Asynchronous Reset</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Many new high-performance FPGAs provide built-in multifunction modules that have general applicability to a wide range of applications. Typically, these resources have some sort of reset functionality but are constrained relative to the type of reset topology. Here we will look at Xilinx-specific multiply– accumulate modules for DSP (Digital Signal Processing) applications. The internal structure of a built-in DSP is typically not flexible to varying reset strategies.</p><p class="s9" style="padding-top: 5pt;padding-left: 21pt;text-indent: 0pt;line-height: 107%;text-align: left;">DSPs and other multifunction resources are typically not flexible to varying reset strategies.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 20pt;text-indent: 0pt;text-align: left;">Consider the following code for a multiply and accumulate operation:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">module dspckt(</p><p class="s11" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;line-height: 119%;text-align: left;">output reg [15:0] oDat, input       iReset, iClk,</p><p class="s11" style="padding-left: 25pt;text-indent: 0pt;line-height: 119%;text-align: left;">input      [7:0] iDat1, iDat2); reg        [15:0] multfactor;</p><p class="s11" style="padding-top: 5pt;padding-left: 30pt;text-indent: -4pt;line-height: 119%;text-align: left;">always @(posedge iClk or negedge iReset) if(!iReset) begin</p><p class="s11" style="padding-left: 34pt;text-indent: 0pt;text-align: left;">multfactor &lt;= 0;</p><p class="s11" style="padding-top: 1pt;padding-left: 30pt;text-indent: 4pt;line-height: 119%;text-align: left;">oDat       &lt;= 0; end</p><p class="s11" style="padding-left: 30pt;text-indent: 0pt;text-align: left;">else begin</p><p class="s11" style="padding-top: 1pt;padding-left: 34pt;text-indent: 0pt;line-height: 119%;text-align: left;">multfactor &lt;= (iDat1 * iDat2); oDat       &lt;= multfactor + oDat;</p><p class="s11" style="padding-left: 20pt;text-indent: 4pt;line-height: 152%;text-align: left;">end endmodule</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">The above code defines a multiply– accumulate function with asynchronous resets. The DSP structures inside a Xilinx Virtex-4 device, for example, have only synchronous reset capabilities as shown in Figure 2.8.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">The reset signal here is fed directly into the reset pin of the MAC core. To implement an asynchronous reset as shown in the above code example, on the other hand, the synthesis tool must create additional logic outside of the DSP core.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="372" height="264" alt="image" src="2 AdvancedFPGADesign_ch2/Image_020.png"/></span></p><p class="s14" style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Figure 2.8   <span class="s7">Xilinx DSP block with synchronous reset.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 8pt;text-indent: 0pt;text-align: left;">Table 2.3    <span class="s9">Resource Utilization for Synchronous and Asynchronous Resets</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:5.52763pt" cellspacing="0"><tr style="height:16pt"><td style="width:52pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Architecture</p></td><td style="width:38pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-top: 3pt;padding-left: 10pt;text-indent: 0pt;text-align: left;">Slices</p></td><td style="width:50pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-top: 3pt;padding-left: 10pt;text-indent: 0pt;text-align: left;">Flip-flops</p></td><td style="width:38pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-top: 3pt;padding-left: 10pt;text-indent: 0pt;text-align: left;">LUTs</p></td><td style="width:30pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-top: 3pt;padding-left: 10pt;text-indent: 0pt;text-align: left;">DSPs</p></td></tr><tr style="height:13pt"><td style="width:52pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20"><p class="s26" style="padding-top: 3pt;padding-left: 2pt;text-indent: 0pt;text-align: left;">Async Reset</p></td><td style="width:38pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20"><p class="s26" style="padding-top: 3pt;text-indent: 0pt;text-align: center;">17</p></td><td style="width:50pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20"><p class="s26" style="padding-top: 3pt;text-indent: 0pt;text-align: center;">32</p></td><td style="width:38pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20"><p class="s26" style="padding-top: 3pt;text-indent: 0pt;text-align: center;">16</p></td><td style="width:30pt;border-top-style:solid;border-top-width:1pt;border-top-color:#231F20"><p class="s26" style="padding-top: 3pt;padding-left: 16pt;text-indent: 0pt;text-align: left;">1</p></td></tr><tr style="height:13pt"><td style="width:52pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Sync Reset</p></td><td style="width:38pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-left: 3pt;text-indent: 0pt;line-height: 8pt;text-align: center;">0</p></td><td style="width:50pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-left: 3pt;text-indent: 0pt;line-height: 8pt;text-align: center;">0</p></td><td style="width:38pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-left: 3pt;text-indent: 0pt;line-height: 8pt;text-align: center;">0</p></td><td style="width:30pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-left: 16pt;text-indent: 0pt;line-height: 8pt;text-align: left;">1</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 8pt;text-indent: 0pt;text-align: justify;">Comparing this to a similar structure using synchronous resets, we are able to obtain the results shown in Table 2.3.</p><p style="padding-left: 8pt;text-indent: 15pt;text-align: justify;">When the synchronous reset was used, the synthesis tool was able to use the DSP core available in the FPGA device. By using a different reset than what was available on this device, however, a significant amount of logic was  created around it to implement the asynchronous reset.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 8pt;text-indent: 0pt;text-align: justify;">2.4.4  Resetting RAM</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 8pt;text-indent: 0pt;text-align: justify;">There are reset resources in many built-in RAM (Random Access Memory) resources for FPGAs, but similar to the DSP resource described in the previous sections, often only synchronous resets are available. Attempting to implement an asynchronous reset on a RAM module can be catastrophic to area optimization because there are not smaller elements that can be optimally used to construct a RAM (like a multiplier and an adder can be stitched together to form a MAC module) other than smaller RAM resources, nor can the synthesis tool easily add a few gates to the output to emulate this functionality.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-left: 23pt;text-indent: 0pt;line-height: 107%;text-align: left;">Resetting RAM is usually poor design practice, particularly if the reset is asynchronous.</p><p style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">Consider the following code:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 23pt;text-indent: 0pt;text-align: left;">module resetckt(</p><p class="s11" style="padding-top: 1pt;padding-left: 28pt;text-indent: 0pt;text-align: left;">output reg [15:0] oDat,</p><p class="s11" style="padding-top: 1pt;padding-left: 28pt;text-indent: 0pt;text-align: left;">input       iReset, iClk, iWrEn,</p><p class="s11" style="padding-top: 1pt;padding-left: 28pt;text-indent: 0pt;text-align: left;">input      [7:0] iAddr, oAddr,</p><p class="s11" style="padding-top: 1pt;padding-left: 28pt;text-indent: 0pt;text-align: left;">input      [15:0] iDat);</p><p class="s11" style="padding-top: 1pt;padding-left: 28pt;text-indent: 0pt;text-align: left;">reg        [15:0] memdat [0:255];</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 28pt;text-indent: 0pt;line-height: 119%;text-align: left;">always @(posedge iClk or negedge iReset) if(!iReset)</p><p class="s11" style="padding-left: 32pt;text-indent: 0pt;text-align: left;">oDat          &lt;= 0;</p><p class="s11" style="padding-top: 1pt;padding-left: 32pt;text-indent: -4pt;line-height: 119%;text-align: left;">else begin if(iWrEn)</p><p class="s11" style="text-indent: 0pt;text-align: center;">memdat[iAddr] &lt;= iDat;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 28pt;text-indent: 4pt;line-height: 119%;text-align: left;">oDat          &lt;= memdat[oAddr]; end</p><p class="s11" style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">endmodule</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="374" height="171" alt="image" src="2 AdvancedFPGADesign_ch2/Image_021.png"/></span></p><p class="s14" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: justify;">Figure 2.9    <span class="s7">Xilinx BRAM with synchronous reset.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 9pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="372" height="111" alt="image" src="2 AdvancedFPGADesign_ch2/Image_022.png"/></span></p><p class="s14" style="padding-top: 4pt;padding-left: 9pt;text-indent: 0pt;text-align: justify;">Figure 2.10   <span class="s7">Xilinx BRAM with asynchronous reset logic.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 8pt;text-indent: 0pt;text-align: justify;">Again, the only variation we will consider in the above code is the type of reset: synchronous versus asynchronous. In Xilinx Virtex-4 devices, for example, BRAM (Block RAM) elements have synchronous resets only. Therefore, with a synchronous reset, the synthesis tool will be able to implement this code with a single BRAM element as shown in Figure 2.9.</p><p style="padding-left: 8pt;text-indent: 15pt;text-align: justify;">However, if we attempt to implement the same RAM with an asynchronous reset as shown in the code example above, the synthesis tool will be forced to create a RAM module with smaller distributed RAM blocks, additional decode logic to create the appropriate-size RAM, and additional logic to implement the asynchronous reset as partially shown in Figure 2.10. The final implementation differences are staggering as shown in Table 2.4.</p><p class="s9" style="padding-top: 6pt;padding-left: 24pt;text-indent: 0pt;text-align: left;">Improperly resetting a RAM can have a catastrophic impact on the area.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 8pt;text-indent: 0pt;text-align: left;">Table 2.4    <span class="s9">Resource Utilization for BRAM with Synchronous and Asynchronous Resets</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 8pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="300" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_023.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><span><img width="298" height="1" alt="image" src="2 AdvancedFPGADesign_ch2/Image_024.png"/></span></p><table style="border-collapse:collapse" cellspacing="0"><tr style="height:9pt"><td style="width:72pt"><p class="s26" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Asynchronous reset</p></td><td style="width:36pt"><p class="s26" style="padding-left: 8pt;text-indent: 0pt;line-height: 8pt;text-align: left;">3415</p></td><td style="width:42pt"><p class="s26" style="padding-left: 12pt;text-indent: 0pt;line-height: 8pt;text-align: left;">4112</p></td><td style="width:45pt"><p class="s26" style="padding-left: 14pt;text-indent: 0pt;line-height: 8pt;text-align: left;">2388</p></td><td style="width:31pt"><p class="s26" style="padding-left: 5pt;text-indent: 0pt;line-height: 8pt;text-align: center;">0</p></td></tr><tr style="height:13pt"><td style="width:72pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-left: 2pt;text-indent: 0pt;line-height: 8pt;text-align: left;">Synchronous reset</p></td><td style="width:36pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-left: 7pt;text-indent: 0pt;line-height: 8pt;text-align: center;">0</p></td><td style="width:42pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: center;">0</p></td><td style="width:45pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-left: 9pt;text-indent: 0pt;line-height: 8pt;text-align: center;">0</p></td><td style="width:31pt;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#231F20"><p class="s26" style="padding-left: 5pt;text-indent: 0pt;line-height: 8pt;text-align: center;">1</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"/><p class="s9" style="padding-top: 2pt;padding-left: 8pt;text-indent: 0pt;text-align: justify;">Implementation          Slices slice    Flip-flops    4 Input LUTs    BRAMs</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s25" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">2.4.5  Utilizing Set<span class="s28">/</span>Reset Flip-Flop Pins</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Most FPGA vendors have a variety of flip-flop elements available in any given device, and given a particular logic function, the synthesis tool can often use the set and reset pins to implement aspects of the logic and reduce the burden on the look-up tables. For instance, consider Figure 2.11. In this case, the synthesis tool may choose to implement the logic using the set pin on a flip-flop as shown in Figure 2.12. This eliminates gates and increases the speed of the data path. Likewise, consider a logic function of the form illustrated in Figure 2.13. The AND gate can be eliminated by running the input signal to the reset pin of the flip-flop as shown in Figure 2.14.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">The primary reason synthesis tools are prevented from performing this class of optimizations is related to the reset strategy. Any constraints on the reset will not only use available set<span class="s5">/</span>reset pins but will also limit the number of library elements to choose from.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s9" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">Using set and reset can prevent certain combinatorial logic optimizations.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">For instance, consider the following implementation in a Xilinx Spartan-3 device:</p><p class="s11" style="padding-top: 6pt;padding-left: 25pt;text-indent: -4pt;line-height: 119%;text-align: left;">module setreset( output reg oDat,</p><p class="s11" style="padding-left: 25pt;text-indent: 0pt;text-align: left;">input     iReset, iClk,</p><p class="s11" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">input     iDat1, iDat2);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 29pt;text-indent: -4pt;line-height: 119%;text-align: left;">always @(posedge iClk or negedge iReset) if(!iReset)</p><p class="s11" style="padding-left: 29pt;text-indent: 4pt;line-height: 119%;text-align: left;">oDat &lt;= 0; else</p><p class="s11" style="padding-left: 20pt;text-indent: 13pt;line-height: 130%;text-align: left;">oDat &lt;= iDat1 | iDat2; endmodule</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="245" height="70" alt="image" src="2 AdvancedFPGADesign_ch2/Image_025.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Figure 2.11   <span class="s7">Simple synchronous logic with OR gate.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="204" height="76" alt="image" src="2 AdvancedFPGADesign_ch2/Image_026.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Figure 2.12   <span class="s7">OR gate implemented with set pin.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="245" height="69" alt="image" src="2 AdvancedFPGADesign_ch2/Image_027.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Figure 2.13   <span class="s7">Simple synchronous logic with AND gate.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="203" height="100" alt="image" src="2 AdvancedFPGADesign_ch2/Image_028.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Figure 2.14   <span class="s7">AND gate implemented with CLR pin.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">In the code example above, an external reset signal is used to reset the state of the flip-flop. This is represented in Figure 2.15.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">As can be seen in Figure 2.15, a resetable flip-flop was used for the asynchro- nous reset capability, and the logic function (OR gate) was implemented in dis- crete logic. As an alternative, if we remove the reset but implement the same logic function, our design will be optimized as shown in Figure 2.16.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: justify;">In this implementation, the synthesis tool was able to use the FDS element (flip-flop with a synchronous set and reset) and use the set pin for the OR oper- ation. Thus, by allowing the synthesis tool to choose a flip-flop with a synchro- nous set, we are able to implement this function with zero logic elements.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="372" height="130" alt="image" src="2 AdvancedFPGADesign_ch2/Image_029.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Figure 2.15    <span class="s7">Simple asynchronous reset.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="372" height="196" alt="image" src="2 AdvancedFPGADesign_ch2/Image_030.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s14" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Figure 2.16    <span class="s7">Optimization without reset.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 15pt;text-align: left;">We can take this one step further by using both synchronous set and reset signals. If we have a logic equation to evaluate in the form of</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 88pt;text-indent: 0pt;text-align: left;">oDat <span class="s17">,</span><span class="s29">¼ </span><span class="s30">!</span>iDat3 <span class="s30">&amp; </span>(iDat1 <span class="s29">j </span>iDat2)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">we can code this in such a way that both the synchronous set and reset resources are used:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 25pt;text-indent: -4pt;line-height: 119%;text-align: justify;">module setreset ( output reg oDat, input iClk,</p><p class="s11" style="padding-left: 25pt;text-indent: 0pt;text-align: justify;">input iDat1, iDat2, iDat3);</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s11" style="padding-left: 29pt;text-indent: -4pt;line-height: 119%;text-align: left;">always @(posedge iClk) if(iDat3)</p><p class="s11" style="padding-left: 29pt;text-indent: 0pt;line-height: 119%;text-align: left;">oDat &lt;= 0; else if(iDat1)</p><p class="s11" style="padding-left: 29pt;text-indent: 4pt;line-height: 119%;text-align: left;">oDat &lt;= 1; else</p><p class="s11" style="padding-left: 20pt;text-indent: 13pt;line-height: 185%;text-align: left;">oDat &lt;= iDat2; endmodule</p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Here, the iDat3 input takes priority similar to the reset pin on the associated flip-flops.  Thus,  this  logic  function  can  be  implemented  as  shown   in Figure 2.17.</p><p style="padding-left: 5pt;text-indent: 15pt;text-align: left;">In this circuit, we have three logical operations (invert, AND, and OR) all implemented with a single flip-flop and zero LUTs. Because these optimizations</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span><img width="372" height="279" alt="image" src="2 AdvancedFPGADesign_ch2/Image_031.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s31" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Figure 2.17  <span class="s7">Optimization using both set and reset pins.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">are not always known at the time the design is architected, avoid using set or reset whenever possible when area is the key consideration.</p><p class="s9" style="padding-top: 5pt;padding-left: 20pt;text-indent: 0pt;text-align: left;">Avoid using set or reset whenever possible when area is the key consideration.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l2"><ol id="l3"><li style="padding-left: 29pt;text-indent: -24pt;text-align: left;"><p class="s16" style="display: inline;">SUMMARY OF KEY POINTS</p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l4"><li style="padding-left: 26pt;text-indent: -6pt;text-align: justify;"><p style="display: inline;">Rolling up the pipeline can optimize the area of pipelined designs with duplicated logic in the pipeline stages.</p></li><li style="padding-top: 2pt;padding-left: 26pt;text-indent: -6pt;text-align: justify;"><p style="display: inline;">Controls can be used to direct the reuse of logic when the shared logic is larger than the control logic.</p></li><li style="padding-top: 2pt;padding-left: 26pt;text-indent: -6pt;text-align: justify;"><p style="display: inline;">For compact designs where area is the primary requirement, search for resources that have similar counterparts in other modules that can be brought to a global point in the hierarchy and shared between multiple functional areas.</p></li><li style="padding-top: 2pt;padding-left: 26pt;text-indent: -6pt;text-align: justify;"><p style="display: inline;">An improper reset strategy can create an unnecessarily large design and inhibit certain area optimizations.</p></li><li style="padding-top: 2pt;padding-left: 26pt;text-indent: -6pt;text-align: justify;"><p style="display: inline;">An optimized FPGA resource will not be used if an incompatible reset is assigned to it. The function will be implemented with generic elements and will occupy more area.</p></li></ul></li></ol></ol><p class="s9" style="padding-top: 4pt;padding-left: 169pt;text-indent: 0pt;text-align: left;">2.5 Summary of Key Points     <span class="s13">35</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ul id="l5"><li style="padding-top: 3pt;padding-left: 11pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">DSPs and other multifunction resources are typically not flexible to varying reset strategies.</p></li><li style="padding-top: 2pt;padding-left: 11pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">Improperly resetting a RAM can have a catastrophic impact on the area.</p></li><li style="padding-top: 2pt;padding-left: 11pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">Using set and reset can prevent certain combinatorial logic optimizations.</p></li><li style="padding-top: 2pt;padding-left: 11pt;text-indent: -6pt;text-align: left;"><p style="display: inline;">Avoid  using  set  or  reset  whenever  possible  when  area  is  the  key consideration.</p></li></ul></body></html>
